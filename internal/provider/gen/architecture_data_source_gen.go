// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package gen

import (
	"context"
	"fmt"
	"github.com/Azure/terraform-provider-alz/internal/alztypes"
	"github.com/Azure/terraform-provider-alz/internal/alzvalidators"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/datasource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ArchitectureDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
				MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
			},
			"location": schema.StringAttribute{
				Required:            true,
				Description:         "The Azure region used as a default for resources.",
				MarkdownDescription: "The Azure region used as a default for resources.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"management_groups": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"display_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The display name of the management group.",
							MarkdownDescription: "The display name of the management group.",
						},
						"exists": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether the management group already exists or not. Used to determine if the management group should be created or just have policy/role resources created within.",
							MarkdownDescription: "Whether the management group already exists or not. Used to determine if the management group should be created or just have policy/role resources created within.",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "The id of the management group. This the last segment of the resource id.",
							MarkdownDescription: "The id of the management group. This the last segment of the resource id.",
						},
						"level": schema.NumberAttribute{
							Computed:            true,
							Description:         "The level of the management group in the hierarchy, relative to the supplied root management group. The level starts at zero.",
							MarkdownDescription: "The level of the management group in the hierarchy, relative to the supplied root management group. The level starts at zero.",
						},
						"parent_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The parent management group id.",
							MarkdownDescription: "The parent management group id.",
						},
						"policy_assignments": schema.MapAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "The policy assignments to apply to the management group. The key is the policy assignment name, and the value is the policy assignment JSON as a string.",
							MarkdownDescription: "The policy assignments to apply to the management group. The key is the policy assignment name, and the value is the policy assignment JSON as a string.",
						},
						"policy_definitions": schema.MapAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "The policy definitions to apply to the management group. The key is the policy definition name, and the value is the policy definition JSON as a string.",
							MarkdownDescription: "The policy definitions to apply to the management group. The key is the policy definition name, and the value is the policy definition JSON as a string.",
						},
						"policy_set_definitions": schema.MapAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "The policy set definitions to apply to the management group. The key is the policy set definition name, and the value is the policy set definition JSON as a string.",
							MarkdownDescription: "The policy set definitions to apply to the management group. The key is the policy set definition name, and the value is the policy set definition JSON as a string.",
						},
						"role_definitions": schema.MapAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "The role definitions to apply to the management group. The key is the role definition name, and the value is the role definition JSON as a string.",
							MarkdownDescription: "The role definitions to apply to the management group. The key is the role definition name, and the value is the role definition JSON as a string.",
						},
					},
					CustomType: ManagementGroupsType{
						ObjectType: types.ObjectType{
							AttrTypes: ManagementGroupsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "This is a list of objects pertaining to the tier of management groups to be deployed (relative to the supplied root management group id). Use the `level` attribute to specify the tier of management groups to deploy.",
				MarkdownDescription: "This is a list of objects pertaining to the tier of management groups to be deployed (relative to the supplied root management group id). Use the `level` attribute to specify the tier of management groups to deploy.",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the architecture to deploy.",
				MarkdownDescription: "The name of the architecture to deploy.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"policy_assignments_to_modify": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"policy_assignments": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"enforcement_mode": schema.StringAttribute{
										Optional:            true,
										Description:         "The enforcement mode for the policy assignment. Valid values are `Default` and `DoNotEnforce`.",
										MarkdownDescription: "The enforcement mode for the policy assignment. Valid values are `Default` and `DoNotEnforce`.",
										Validators: []validator.String{
											stringvalidator.OneOf("Default", "DoNotEnforce"),
										},
									},
									"identity": schema.StringAttribute{
										Optional:            true,
										Description:         "The identity type. Must be one of `SystemAssigned` or `UserAssigned`.",
										MarkdownDescription: "The identity type. Must be one of `SystemAssigned` or `UserAssigned`.",
										Validators: []validator.String{
											stringvalidator.OneOf("SystemAssigned", "UserAssigned"),
										},
									},
									"identity_ids": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A set of zero or one identity ids to assign to the policy assignment. Required if `identity` is `UserAssigned`. **Do not** pass in computed values, instead construct the resource id yourself.",
										MarkdownDescription: "A set of zero or one identity ids to assign to the policy assignment. Required if `identity` is `UserAssigned`. **Do not** pass in computed values, instead construct the resource id yourself.",
										Validators: []validator.Set{
											setvalidator.ValueStringsAre(alzvalidators.ArmResourceIdTypeNamespace("Microsoft.ManagedIdentity", "userAssignedIdentities")),
											setvalidator.AlsoRequires(path.MatchRelative().AtParent().AtName("identity")),
											setvalidator.SizeBetween(0, 1),
										},
									},
									"non_compliance_messages": schema.SetNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"message": schema.StringAttribute{
													Required:            true,
													Description:         "The non-compliance message to use for the policy assignment.",
													MarkdownDescription: "The non-compliance message to use for the policy assignment.",
												},
												"policy_definition_reference_id": schema.StringAttribute{
													Optional:            true,
													Description:         "The policy definition reference id (not the resource id) to use for the non compliance message. This references the definition within the policy set.",
													MarkdownDescription: "The policy definition reference id (not the resource id) to use for the non compliance message. This references the definition within the policy set.",
												},
											},
											CustomType: NonComplianceMessagesType{
												ObjectType: types.ObjectType{
													AttrTypes: NonComplianceMessagesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "The non-compliance messages to use for the policy assignment.",
										MarkdownDescription: "The non-compliance messages to use for the policy assignment.",
									},
									"overrides": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"kind": schema.StringAttribute{
													Required:            true,
													Description:         "The property the assignment will override. The supported kind is `policyEffect`.",
													MarkdownDescription: "The property the assignment will override. The supported kind is `policyEffect`.",
													Validators: []validator.String{
														stringvalidator.OneOf("policyEffect"),
													},
												},
												"override_selectors": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"in": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "The list of values that the selector will match. Conflicts with `not_in`.",
																MarkdownDescription: "The list of values that the selector will match. Conflicts with `not_in`.",
																Validators: []validator.Set{
																	setvalidator.SizeAtMost(50),
																	setvalidator.ConflictsWith(path.MatchRelative().AtParent().AtName("not_in")),
																},
															},
															"kind": schema.StringAttribute{
																Required:            true,
																Description:         "The property of a selector that describes what characteristic will narrow down the scope of the override. Allowed value for kind: `policyEffect` is: `policyDefinitionReferenceId`.",
																MarkdownDescription: "The property of a selector that describes what characteristic will narrow down the scope of the override. Allowed value for kind: `policyEffect` is: `policyDefinitionReferenceId`.",
																Validators: []validator.String{
																	stringvalidator.OneOf("policyDefinitionReferenceId"),
																},
															},
															"not_in": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "The list of values that the selector will not match. Conflicts with `in`.",
																MarkdownDescription: "The list of values that the selector will not match. Conflicts with `in`.",
																Validators: []validator.Set{
																	setvalidator.SizeAtMost(50),
																	setvalidator.ConflictsWith(path.MatchRelative().AtParent().AtName("not_in")),
																},
															},
														},
														CustomType: OverrideSelectorsType{
															ObjectType: types.ObjectType{
																AttrTypes: OverrideSelectorsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "The selectors to use for the override.",
													MarkdownDescription: "The selectors to use for the override.",
												},
												"value": schema.StringAttribute{
													Required:            true,
													Description:         "The new value which will override the existing value. The supported values are: `addToNetworkGroup`, `append`, `audit`, `auditIfNotExists`, `deny`, `denyAction`, `deployIfNotExists`, `disabled`, `manual`, `modify`, `mutate`. <https://learn.microsoft.com/azure/governance/policy/concepts/effects>",
													MarkdownDescription: "The new value which will override the existing value. The supported values are: `addToNetworkGroup`, `append`, `audit`, `auditIfNotExists`, `deny`, `denyAction`, `deployIfNotExists`, `disabled`, `manual`, `modify`, `mutate`. <https://learn.microsoft.com/azure/governance/policy/concepts/effects>",
													Validators: []validator.String{
														stringvalidator.OneOf("addToNetworkGroup", "append", "audit", "auditIfNotExists", "deny", "denyAction", "deployIfNotExists", "disabled", "manual", "modify", "mutate"),
													},
												},
											},
											CustomType: OverridesType{
												ObjectType: types.ObjectType{
													AttrTypes: OverridesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "The overrides for this policy assignment. There are a maximum of 10 overrides allowed per assignment. If specified here the overrides will replace the existing overrides.",
										MarkdownDescription: "The overrides for this policy assignment. There are a maximum of 10 overrides allowed per assignment. If specified here the overrides will replace the existing overrides.",
										Validators: []validator.List{
											listvalidator.SizeAtMost(10),
											listvalidator.UniqueValues(),
										},
									},
									"parameters": schema.StringAttribute{
										CustomType:          alztypes.PolicyParameterType{},
										Optional:            true,
										Description:         "The parameters to use for the policy assignment. **Note:** This is a JSON string, and not a map. This is because the parameter values have different types, which confuses the type system used by the provider sdk. Use `jsonencode()` to construct the map. The map keys must be strings, the values are `any` type. Example: `jsonencode({\"param1\": \"value1\", \"param2\": 2})`",
										MarkdownDescription: "The parameters to use for the policy assignment. **Note:** This is a JSON string, and not a map. This is because the parameter values have different types, which confuses the type system used by the provider sdk. Use `jsonencode()` to construct the map. The map keys must be strings, the values are `any` type. Example: `jsonencode({\"param1\": \"value1\", \"param2\": 2})`",
									},
									"resource_selectors": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:            true,
													Description:         "The name of the resource selector. The name must be unique within the assignment.",
													MarkdownDescription: "The name of the resource selector. The name must be unique within the assignment.",
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"resource_selector_selectors": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"in": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "The list of values that the selector will match. Conflicts with `not_in`.",
																MarkdownDescription: "The list of values that the selector will match. Conflicts with `not_in`.",
																Validators: []validator.Set{
																	setvalidator.SizeAtMost(50),
																	setvalidator.ConflictsWith(path.MatchRelative().AtParent().AtName("not_in")),
																},
															},
															"kind": schema.StringAttribute{
																Required:            true,
																Description:         "The property of a selector that describes what characteristic will narrow down the set of evaluated resources. Each kind can only be used once in a single resource selector. Allowed values are: `resourceLocation`, `resourceType`, `resourceWithoutLocation`. `resourceWithoutLocation` cannot be used in the same resource selector as `resourceLocation`.",
																MarkdownDescription: "The property of a selector that describes what characteristic will narrow down the set of evaluated resources. Each kind can only be used once in a single resource selector. Allowed values are: `resourceLocation`, `resourceType`, `resourceWithoutLocation`. `resourceWithoutLocation` cannot be used in the same resource selector as `resourceLocation`.",
																Validators: []validator.String{
																	stringvalidator.OneOf("resourceLocation", "resourceType", "resourceWithoutLocation"),
																},
															},
															"not_in": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "The list of values that the selector will not match. Conflicts with `in`.",
																MarkdownDescription: "The list of values that the selector will not match. Conflicts with `in`.",
																Validators: []validator.Set{
																	setvalidator.SizeAtMost(50),
																	setvalidator.ConflictsWith(path.MatchRelative().AtParent().AtName("not_in")),
																},
															},
														},
														CustomType: ResourceSelectorSelectorsType{
															ObjectType: types.ObjectType{
																AttrTypes: ResourceSelectorSelectorsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "The selectors to use for the resource selector.",
													MarkdownDescription: "The selectors to use for the resource selector.",
												},
											},
											CustomType: ResourceSelectorsType{
												ObjectType: types.ObjectType{
													AttrTypes: ResourceSelectorsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "The resource selectors to use for the policy assignment. A maximum of 10 resource selectors are allowed per assignment. If specified here the resource selectors will replace any existing resource selectors.",
										MarkdownDescription: "The resource selectors to use for the policy assignment. A maximum of 10 resource selectors are allowed per assignment. If specified here the resource selectors will replace any existing resource selectors.",
										Validators: []validator.List{
											listvalidator.SizeAtMost(10),
											listvalidator.UniqueValues(),
										},
									},
								},
								CustomType: PolicyAssignmentsType{
									ObjectType: types.ObjectType{
										AttrTypes: PolicyAssignmentsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "A map of policy assignments to modify. The key is the policy assignment name, and the value is an object containing the modifications to make.",
							MarkdownDescription: "A map of policy assignments to modify. The key is the policy assignment name, and the value is an object containing the modifications to make.",
						},
					},
					CustomType: PolicyAssignmentsToModifyType{
						ObjectType: types.ObjectType{
							AttrTypes: PolicyAssignmentsToModifyValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "A mested map of policy assignments to modify. The key is the management group id, and the value is an object with a single attribute, `policy_assignments`. This is another map.",
				MarkdownDescription: "A mested map of policy assignments to modify. The key is the management group id, and the value is an object with a single attribute, `policy_assignments`. This is another map.",
			},
			"policy_role_assignments": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"management_group_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The id of the management group where the policy assignment will be created.",
							MarkdownDescription: "The id of the management group where the policy assignment will be created.",
						},
						"policy_assignment_name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name of the policy assignment to enable retrieval of the identity id.",
							MarkdownDescription: "The name of the policy assignment to enable retrieval of the identity id.",
						},
						"role_definition_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The role definition id to assign.",
							MarkdownDescription: "The role definition id to assign.",
						},
						"scope": schema.StringAttribute{
							Computed:            true,
							Description:         "The scope of the assignment.",
							MarkdownDescription: "The scope of the assignment.",
						},
					},
					CustomType: PolicyRoleAssignmentsType{
						ObjectType: types.ObjectType{
							AttrTypes: PolicyRoleAssignmentsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "A set of role assignments that need to be created for the policies that have been assigned in the hierarchy. Since we will likely be using system assigned identities, we don't know the principal ID until after the deployment. Therefore this data can be used to create the role assignments after the deployment.",
				MarkdownDescription: "A set of role assignments that need to be created for the policies that have been assigned in the hierarchy. Since we will likely be using system assigned identities, we don't know the principal ID until after the deployment. Therefore this data can be used to create the role assignments after the deployment.",
			},
			"root_management_group_id": schema.StringAttribute{
				Required:            true,
				Description:         "The root management group id under which to deploy the architecture.",
				MarkdownDescription: "The root management group id under which to deploy the architecture.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": schema.SingleNestedBlock{
				Attributes: map[string]schema.Attribute{
					"read": schema.StringAttribute{
						Optional:            true,
						Description:         "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours).",
						MarkdownDescription: "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours).",
					},
				},
				CustomType: timeouts.Type{ObjectType: types.ObjectType{AttrTypes: map[string]attr.Type{"read": types.StringType}}},
			},
		},
		Description:         "The architecture data source provides the information required to deploy an ALZ management group hierarchy, including policy and additional role assignment detail.",
		MarkdownDescription: "The architecture data source provides the information required to deploy an ALZ management group hierarchy, including policy and additional role assignment detail.",
	}
}

type ArchitectureModel struct {
	Id                        types.String   `tfsdk:"id"`
	Location                  types.String   `tfsdk:"location"`
	ManagementGroups          types.List     `tfsdk:"management_groups"`
	Name                      types.String   `tfsdk:"name"`
	PolicyAssignmentsToModify types.Map      `tfsdk:"policy_assignments_to_modify"`
	PolicyRoleAssignments     types.Set      `tfsdk:"policy_role_assignments"`
	RootManagementGroupId     types.String   `tfsdk:"root_management_group_id"`
	Timeouts                  timeouts.Value `tfsdk:"timeouts"`
}

var _ basetypes.ObjectTypable = ManagementGroupsType{}

type ManagementGroupsType struct {
	basetypes.ObjectType
}

func (t ManagementGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(ManagementGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ManagementGroupsType) String() string {
	return "ManagementGroupsType"
}

func (t ManagementGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	existsAttribute, ok := attributes["exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exists is missing from object`)

		return nil, diags
	}

	existsVal, ok := existsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exists expected to be basetypes.BoolValue, was: %T`, existsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	levelAttribute, ok := attributes["level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`level is missing from object`)

		return nil, diags
	}

	levelVal, ok := levelAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`level expected to be basetypes.NumberValue, was: %T`, levelAttribute))
	}

	parentIdAttribute, ok := attributes["parent_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_id is missing from object`)

		return nil, diags
	}

	parentIdVal, ok := parentIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_id expected to be basetypes.StringValue, was: %T`, parentIdAttribute))
	}

	policyAssignmentsAttribute, ok := attributes["policy_assignments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignments is missing from object`)

		return nil, diags
	}

	policyAssignmentsVal, ok := policyAssignmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignments expected to be basetypes.MapValue, was: %T`, policyAssignmentsAttribute))
	}

	policyDefinitionsAttribute, ok := attributes["policy_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_definitions is missing from object`)

		return nil, diags
	}

	policyDefinitionsVal, ok := policyDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_definitions expected to be basetypes.MapValue, was: %T`, policyDefinitionsAttribute))
	}

	policySetDefinitionsAttribute, ok := attributes["policy_set_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_set_definitions is missing from object`)

		return nil, diags
	}

	policySetDefinitionsVal, ok := policySetDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_set_definitions expected to be basetypes.MapValue, was: %T`, policySetDefinitionsAttribute))
	}

	roleDefinitionsAttribute, ok := attributes["role_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_definitions is missing from object`)

		return nil, diags
	}

	roleDefinitionsVal, ok := roleDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_definitions expected to be basetypes.MapValue, was: %T`, roleDefinitionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ManagementGroupsValue{
		DisplayName:          displayNameVal,
		Exists:               existsVal,
		Id:                   idVal,
		Level:                levelVal,
		ParentId:             parentIdVal,
		PolicyAssignments:    policyAssignmentsVal,
		PolicyDefinitions:    policyDefinitionsVal,
		PolicySetDefinitions: policySetDefinitionsVal,
		RoleDefinitions:      roleDefinitionsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewManagementGroupsValueNull() ManagementGroupsValue {
	return ManagementGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewManagementGroupsValueUnknown() ManagementGroupsValue {
	return ManagementGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewManagementGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ManagementGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ManagementGroupsValue Attribute Value",
				"While creating a ManagementGroupsValue value, a missing attribute value was detected. "+
					"A ManagementGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ManagementGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ManagementGroupsValue Attribute Type",
				"While creating a ManagementGroupsValue value, an invalid attribute value was detected. "+
					"A ManagementGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ManagementGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ManagementGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ManagementGroupsValue Attribute Value",
				"While creating a ManagementGroupsValue value, an extra attribute value was detected. "+
					"A ManagementGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ManagementGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewManagementGroupsValueUnknown(), diags
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	existsAttribute, ok := attributes["exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exists is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	existsVal, ok := existsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exists expected to be basetypes.BoolValue, was: %T`, existsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	levelAttribute, ok := attributes["level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`level is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	levelVal, ok := levelAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`level expected to be basetypes.NumberValue, was: %T`, levelAttribute))
	}

	parentIdAttribute, ok := attributes["parent_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_id is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	parentIdVal, ok := parentIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_id expected to be basetypes.StringValue, was: %T`, parentIdAttribute))
	}

	policyAssignmentsAttribute, ok := attributes["policy_assignments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignments is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	policyAssignmentsVal, ok := policyAssignmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignments expected to be basetypes.MapValue, was: %T`, policyAssignmentsAttribute))
	}

	policyDefinitionsAttribute, ok := attributes["policy_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_definitions is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	policyDefinitionsVal, ok := policyDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_definitions expected to be basetypes.MapValue, was: %T`, policyDefinitionsAttribute))
	}

	policySetDefinitionsAttribute, ok := attributes["policy_set_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_set_definitions is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	policySetDefinitionsVal, ok := policySetDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_set_definitions expected to be basetypes.MapValue, was: %T`, policySetDefinitionsAttribute))
	}

	roleDefinitionsAttribute, ok := attributes["role_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_definitions is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	roleDefinitionsVal, ok := roleDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_definitions expected to be basetypes.MapValue, was: %T`, roleDefinitionsAttribute))
	}

	if diags.HasError() {
		return NewManagementGroupsValueUnknown(), diags
	}

	return ManagementGroupsValue{
		DisplayName:          displayNameVal,
		Exists:               existsVal,
		Id:                   idVal,
		Level:                levelVal,
		ParentId:             parentIdVal,
		PolicyAssignments:    policyAssignmentsVal,
		PolicyDefinitions:    policyDefinitionsVal,
		PolicySetDefinitions: policySetDefinitionsVal,
		RoleDefinitions:      roleDefinitionsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewManagementGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ManagementGroupsValue {
	object, diags := NewManagementGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewManagementGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ManagementGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewManagementGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewManagementGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewManagementGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewManagementGroupsValueMust(ManagementGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ManagementGroupsType) ValueType(ctx context.Context) attr.Value {
	return ManagementGroupsValue{}
}

var _ basetypes.ObjectValuable = ManagementGroupsValue{}

type ManagementGroupsValue struct {
	DisplayName          basetypes.StringValue `tfsdk:"display_name"`
	Exists               basetypes.BoolValue   `tfsdk:"exists"`
	Id                   basetypes.StringValue `tfsdk:"id"`
	Level                basetypes.NumberValue `tfsdk:"level"`
	ParentId             basetypes.StringValue `tfsdk:"parent_id"`
	PolicyAssignments    basetypes.MapValue    `tfsdk:"policy_assignments"`
	PolicyDefinitions    basetypes.MapValue    `tfsdk:"policy_definitions"`
	PolicySetDefinitions basetypes.MapValue    `tfsdk:"policy_set_definitions"`
	RoleDefinitions      basetypes.MapValue    `tfsdk:"role_definitions"`
	state                attr.ValueState
}

func (v ManagementGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exists"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["level"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["parent_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["policy_assignments"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["policy_definitions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["policy_set_definitions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["role_definitions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Exists.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exists"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Level.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["level"] = val

		val, err = v.ParentId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_id"] = val

		val, err = v.PolicyAssignments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_assignments"] = val

		val, err = v.PolicyDefinitions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_definitions"] = val

		val, err = v.PolicySetDefinitions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_set_definitions"] = val

		val, err = v.RoleDefinitions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_definitions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ManagementGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ManagementGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ManagementGroupsValue) String() string {
	return "ManagementGroupsValue"
}

func (v ManagementGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	policyAssignmentsVal, d := types.MapValue(types.StringType, v.PolicyAssignments.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"display_name": basetypes.StringType{},
			"exists":       basetypes.BoolType{},
			"id":           basetypes.StringType{},
			"level":        basetypes.NumberType{},
			"parent_id":    basetypes.StringType{},
			"policy_assignments": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_set_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"role_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	policyDefinitionsVal, d := types.MapValue(types.StringType, v.PolicyDefinitions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"display_name": basetypes.StringType{},
			"exists":       basetypes.BoolType{},
			"id":           basetypes.StringType{},
			"level":        basetypes.NumberType{},
			"parent_id":    basetypes.StringType{},
			"policy_assignments": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_set_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"role_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	policySetDefinitionsVal, d := types.MapValue(types.StringType, v.PolicySetDefinitions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"display_name": basetypes.StringType{},
			"exists":       basetypes.BoolType{},
			"id":           basetypes.StringType{},
			"level":        basetypes.NumberType{},
			"parent_id":    basetypes.StringType{},
			"policy_assignments": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_set_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"role_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	roleDefinitionsVal, d := types.MapValue(types.StringType, v.RoleDefinitions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"display_name": basetypes.StringType{},
			"exists":       basetypes.BoolType{},
			"id":           basetypes.StringType{},
			"level":        basetypes.NumberType{},
			"parent_id":    basetypes.StringType{},
			"policy_assignments": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_set_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"role_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"display_name": basetypes.StringType{},
		"exists":       basetypes.BoolType{},
		"id":           basetypes.StringType{},
		"level":        basetypes.NumberType{},
		"parent_id":    basetypes.StringType{},
		"policy_assignments": basetypes.MapType{
			ElemType: types.StringType,
		},
		"policy_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"policy_set_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"role_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"display_name":           v.DisplayName,
			"exists":                 v.Exists,
			"id":                     v.Id,
			"level":                  v.Level,
			"parent_id":              v.ParentId,
			"policy_assignments":     policyAssignmentsVal,
			"policy_definitions":     policyDefinitionsVal,
			"policy_set_definitions": policySetDefinitionsVal,
			"role_definitions":       roleDefinitionsVal,
		})

	return objVal, diags
}

func (v ManagementGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(ManagementGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Exists.Equal(other.Exists) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Level.Equal(other.Level) {
		return false
	}

	if !v.ParentId.Equal(other.ParentId) {
		return false
	}

	if !v.PolicyAssignments.Equal(other.PolicyAssignments) {
		return false
	}

	if !v.PolicyDefinitions.Equal(other.PolicyDefinitions) {
		return false
	}

	if !v.PolicySetDefinitions.Equal(other.PolicySetDefinitions) {
		return false
	}

	if !v.RoleDefinitions.Equal(other.RoleDefinitions) {
		return false
	}

	return true
}

func (v ManagementGroupsValue) Type(ctx context.Context) attr.Type {
	return ManagementGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ManagementGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"display_name": basetypes.StringType{},
		"exists":       basetypes.BoolType{},
		"id":           basetypes.StringType{},
		"level":        basetypes.NumberType{},
		"parent_id":    basetypes.StringType{},
		"policy_assignments": basetypes.MapType{
			ElemType: types.StringType,
		},
		"policy_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"policy_set_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"role_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = PolicyAssignmentsToModifyType{}

type PolicyAssignmentsToModifyType struct {
	basetypes.ObjectType
}

func (t PolicyAssignmentsToModifyType) Equal(o attr.Type) bool {
	other, ok := o.(PolicyAssignmentsToModifyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PolicyAssignmentsToModifyType) String() string {
	return "PolicyAssignmentsToModifyType"
}

func (t PolicyAssignmentsToModifyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	policyAssignmentsAttribute, ok := attributes["policy_assignments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignments is missing from object`)

		return nil, diags
	}

	policyAssignmentsVal, ok := policyAssignmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignments expected to be basetypes.MapValue, was: %T`, policyAssignmentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PolicyAssignmentsToModifyValue{
		PolicyAssignments: policyAssignmentsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPolicyAssignmentsToModifyValueNull() PolicyAssignmentsToModifyValue {
	return PolicyAssignmentsToModifyValue{
		state: attr.ValueStateNull,
	}
}

func NewPolicyAssignmentsToModifyValueUnknown() PolicyAssignmentsToModifyValue {
	return PolicyAssignmentsToModifyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPolicyAssignmentsToModifyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PolicyAssignmentsToModifyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PolicyAssignmentsToModifyValue Attribute Value",
				"While creating a PolicyAssignmentsToModifyValue value, a missing attribute value was detected. "+
					"A PolicyAssignmentsToModifyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyAssignmentsToModifyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PolicyAssignmentsToModifyValue Attribute Type",
				"While creating a PolicyAssignmentsToModifyValue value, an invalid attribute value was detected. "+
					"A PolicyAssignmentsToModifyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyAssignmentsToModifyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PolicyAssignmentsToModifyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PolicyAssignmentsToModifyValue Attribute Value",
				"While creating a PolicyAssignmentsToModifyValue value, an extra attribute value was detected. "+
					"A PolicyAssignmentsToModifyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PolicyAssignmentsToModifyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPolicyAssignmentsToModifyValueUnknown(), diags
	}

	policyAssignmentsAttribute, ok := attributes["policy_assignments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignments is missing from object`)

		return NewPolicyAssignmentsToModifyValueUnknown(), diags
	}

	policyAssignmentsVal, ok := policyAssignmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignments expected to be basetypes.MapValue, was: %T`, policyAssignmentsAttribute))
	}

	if diags.HasError() {
		return NewPolicyAssignmentsToModifyValueUnknown(), diags
	}

	return PolicyAssignmentsToModifyValue{
		PolicyAssignments: policyAssignmentsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPolicyAssignmentsToModifyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PolicyAssignmentsToModifyValue {
	object, diags := NewPolicyAssignmentsToModifyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPolicyAssignmentsToModifyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PolicyAssignmentsToModifyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPolicyAssignmentsToModifyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPolicyAssignmentsToModifyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPolicyAssignmentsToModifyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPolicyAssignmentsToModifyValueMust(PolicyAssignmentsToModifyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PolicyAssignmentsToModifyType) ValueType(ctx context.Context) attr.Value {
	return PolicyAssignmentsToModifyValue{}
}

var _ basetypes.ObjectValuable = PolicyAssignmentsToModifyValue{}

type PolicyAssignmentsToModifyValue struct {
	PolicyAssignments basetypes.MapValue `tfsdk:"policy_assignments"`
	state             attr.ValueState
}

func (v PolicyAssignmentsToModifyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["policy_assignments"] = basetypes.MapType{
		ElemType: PolicyAssignmentsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.PolicyAssignments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_assignments"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PolicyAssignmentsToModifyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PolicyAssignmentsToModifyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PolicyAssignmentsToModifyValue) String() string {
	return "PolicyAssignmentsToModifyValue"
}

func (v PolicyAssignmentsToModifyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	policyAssignments := types.MapValueMust(
		PolicyAssignmentsType{
			basetypes.ObjectType{
				AttrTypes: PolicyAssignmentsValue{}.AttributeTypes(ctx),
			},
		},
		v.PolicyAssignments.Elements(),
	)

	if v.PolicyAssignments.IsNull() {
		policyAssignments = types.MapNull(
			PolicyAssignmentsType{
				basetypes.ObjectType{
					AttrTypes: PolicyAssignmentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PolicyAssignments.IsUnknown() {
		policyAssignments = types.MapUnknown(
			PolicyAssignmentsType{
				basetypes.ObjectType{
					AttrTypes: PolicyAssignmentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"policy_assignments": basetypes.MapType{
			ElemType: PolicyAssignmentsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"policy_assignments": policyAssignments,
		})

	return objVal, diags
}

func (v PolicyAssignmentsToModifyValue) Equal(o attr.Value) bool {
	other, ok := o.(PolicyAssignmentsToModifyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PolicyAssignments.Equal(other.PolicyAssignments) {
		return false
	}

	return true
}

func (v PolicyAssignmentsToModifyValue) Type(ctx context.Context) attr.Type {
	return PolicyAssignmentsToModifyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PolicyAssignmentsToModifyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"policy_assignments": basetypes.MapType{
			ElemType: PolicyAssignmentsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PolicyAssignmentsType{}

type PolicyAssignmentsType struct {
	basetypes.ObjectType
}

func (t PolicyAssignmentsType) Equal(o attr.Type) bool {
	other, ok := o.(PolicyAssignmentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PolicyAssignmentsType) String() string {
	return "PolicyAssignmentsType"
}

func (t PolicyAssignmentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enforcementModeAttribute, ok := attributes["enforcement_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enforcement_mode is missing from object`)

		return nil, diags
	}

	enforcementModeVal, ok := enforcementModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enforcement_mode expected to be basetypes.StringValue, was: %T`, enforcementModeAttribute))
	}

	identityAttribute, ok := attributes["identity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity is missing from object`)

		return nil, diags
	}

	identityVal, ok := identityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity expected to be basetypes.StringValue, was: %T`, identityAttribute))
	}

	identityIdsAttribute, ok := attributes["identity_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity_ids is missing from object`)

		return nil, diags
	}

	identityIdsVal, ok := identityIdsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity_ids expected to be basetypes.SetValue, was: %T`, identityIdsAttribute))
	}

	nonComplianceMessagesAttribute, ok := attributes["non_compliance_messages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`non_compliance_messages is missing from object`)

		return nil, diags
	}

	nonComplianceMessagesVal, ok := nonComplianceMessagesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`non_compliance_messages expected to be basetypes.SetValue, was: %T`, nonComplianceMessagesAttribute))
	}

	overridesAttribute, ok := attributes["overrides"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overrides is missing from object`)

		return nil, diags
	}

	overridesVal, ok := overridesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overrides expected to be basetypes.ListValue, was: %T`, overridesAttribute))
	}

	parametersAttribute, ok := attributes["parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parameters is missing from object`)

		return nil, diags
	}

	parametersVal, ok := parametersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parameters expected to be basetypes.StringValue, was: %T`, parametersAttribute))
	}

	resourceSelectorsAttribute, ok := attributes["resource_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_selectors is missing from object`)

		return nil, diags
	}

	resourceSelectorsVal, ok := resourceSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_selectors expected to be basetypes.ListValue, was: %T`, resourceSelectorsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PolicyAssignmentsValue{
		EnforcementMode:       enforcementModeVal,
		Identity:              identityVal,
		IdentityIds:           identityIdsVal,
		NonComplianceMessages: nonComplianceMessagesVal,
		Overrides:             overridesVal,
		Parameters:            parametersVal,
		ResourceSelectors:     resourceSelectorsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPolicyAssignmentsValueNull() PolicyAssignmentsValue {
	return PolicyAssignmentsValue{
		state: attr.ValueStateNull,
	}
}

func NewPolicyAssignmentsValueUnknown() PolicyAssignmentsValue {
	return PolicyAssignmentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPolicyAssignmentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PolicyAssignmentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PolicyAssignmentsValue Attribute Value",
				"While creating a PolicyAssignmentsValue value, a missing attribute value was detected. "+
					"A PolicyAssignmentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyAssignmentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PolicyAssignmentsValue Attribute Type",
				"While creating a PolicyAssignmentsValue value, an invalid attribute value was detected. "+
					"A PolicyAssignmentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyAssignmentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PolicyAssignmentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PolicyAssignmentsValue Attribute Value",
				"While creating a PolicyAssignmentsValue value, an extra attribute value was detected. "+
					"A PolicyAssignmentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PolicyAssignmentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPolicyAssignmentsValueUnknown(), diags
	}

	enforcementModeAttribute, ok := attributes["enforcement_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enforcement_mode is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	enforcementModeVal, ok := enforcementModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enforcement_mode expected to be basetypes.StringValue, was: %T`, enforcementModeAttribute))
	}

	identityAttribute, ok := attributes["identity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	identityVal, ok := identityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity expected to be basetypes.StringValue, was: %T`, identityAttribute))
	}

	identityIdsAttribute, ok := attributes["identity_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity_ids is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	identityIdsVal, ok := identityIdsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity_ids expected to be basetypes.SetValue, was: %T`, identityIdsAttribute))
	}

	nonComplianceMessagesAttribute, ok := attributes["non_compliance_messages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`non_compliance_messages is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	nonComplianceMessagesVal, ok := nonComplianceMessagesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`non_compliance_messages expected to be basetypes.SetValue, was: %T`, nonComplianceMessagesAttribute))
	}

	overridesAttribute, ok := attributes["overrides"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overrides is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	overridesVal, ok := overridesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overrides expected to be basetypes.ListValue, was: %T`, overridesAttribute))
	}

	parametersAttribute, ok := attributes["parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parameters is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	parametersVal, ok := parametersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parameters expected to be basetypes.StringValue, was: %T`, parametersAttribute))
	}

	resourceSelectorsAttribute, ok := attributes["resource_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_selectors is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	resourceSelectorsVal, ok := resourceSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_selectors expected to be basetypes.ListValue, was: %T`, resourceSelectorsAttribute))
	}

	if diags.HasError() {
		return NewPolicyAssignmentsValueUnknown(), diags
	}

	return PolicyAssignmentsValue{
		EnforcementMode:       enforcementModeVal,
		Identity:              identityVal,
		IdentityIds:           identityIdsVal,
		NonComplianceMessages: nonComplianceMessagesVal,
		Overrides:             overridesVal,
		Parameters:            parametersVal,
		ResourceSelectors:     resourceSelectorsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPolicyAssignmentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PolicyAssignmentsValue {
	object, diags := NewPolicyAssignmentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPolicyAssignmentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PolicyAssignmentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPolicyAssignmentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPolicyAssignmentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPolicyAssignmentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPolicyAssignmentsValueMust(PolicyAssignmentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PolicyAssignmentsType) ValueType(ctx context.Context) attr.Value {
	return PolicyAssignmentsValue{}
}

var _ basetypes.ObjectValuable = PolicyAssignmentsValue{}

type PolicyAssignmentsValue struct {
	EnforcementMode       basetypes.StringValue `tfsdk:"enforcement_mode"`
	Identity              basetypes.StringValue `tfsdk:"identity"`
	IdentityIds           basetypes.SetValue    `tfsdk:"identity_ids"`
	NonComplianceMessages basetypes.SetValue    `tfsdk:"non_compliance_messages"`
	Overrides             basetypes.ListValue   `tfsdk:"overrides"`
	Parameters            basetypes.StringValue `tfsdk:"parameters"`
	ResourceSelectors     basetypes.ListValue   `tfsdk:"resource_selectors"`
	state                 attr.ValueState
}

func (v PolicyAssignmentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["enforcement_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["identity"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["identity_ids"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["non_compliance_messages"] = basetypes.SetType{
		ElemType: NonComplianceMessagesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["overrides"] = basetypes.ListType{
		ElemType: OverridesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["parameters"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_selectors"] = basetypes.ListType{
		ElemType: ResourceSelectorsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.EnforcementMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enforcement_mode"] = val

		val, err = v.Identity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identity"] = val

		val, err = v.IdentityIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identity_ids"] = val

		val, err = v.NonComplianceMessages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["non_compliance_messages"] = val

		val, err = v.Overrides.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overrides"] = val

		val, err = v.Parameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parameters"] = val

		val, err = v.ResourceSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_selectors"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PolicyAssignmentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PolicyAssignmentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PolicyAssignmentsValue) String() string {
	return "PolicyAssignmentsValue"
}

func (v PolicyAssignmentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	nonComplianceMessages := types.SetValueMust(
		NonComplianceMessagesType{
			basetypes.ObjectType{
				AttrTypes: NonComplianceMessagesValue{}.AttributeTypes(ctx),
			},
		},
		v.NonComplianceMessages.Elements(),
	)

	if v.NonComplianceMessages.IsNull() {
		nonComplianceMessages = types.SetNull(
			NonComplianceMessagesType{
				basetypes.ObjectType{
					AttrTypes: NonComplianceMessagesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NonComplianceMessages.IsUnknown() {
		nonComplianceMessages = types.SetUnknown(
			NonComplianceMessagesType{
				basetypes.ObjectType{
					AttrTypes: NonComplianceMessagesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	overrides := types.ListValueMust(
		OverridesType{
			basetypes.ObjectType{
				AttrTypes: OverridesValue{}.AttributeTypes(ctx),
			},
		},
		v.Overrides.Elements(),
	)

	if v.Overrides.IsNull() {
		overrides = types.ListNull(
			OverridesType{
				basetypes.ObjectType{
					AttrTypes: OverridesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Overrides.IsUnknown() {
		overrides = types.ListUnknown(
			OverridesType{
				basetypes.ObjectType{
					AttrTypes: OverridesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	resourceSelectors := types.ListValueMust(
		ResourceSelectorsType{
			basetypes.ObjectType{
				AttrTypes: ResourceSelectorsValue{}.AttributeTypes(ctx),
			},
		},
		v.ResourceSelectors.Elements(),
	)

	if v.ResourceSelectors.IsNull() {
		resourceSelectors = types.ListNull(
			ResourceSelectorsType{
				basetypes.ObjectType{
					AttrTypes: ResourceSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ResourceSelectors.IsUnknown() {
		resourceSelectors = types.ListUnknown(
			ResourceSelectorsType{
				basetypes.ObjectType{
					AttrTypes: ResourceSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	identityIdsVal, d := types.SetValue(types.StringType, v.IdentityIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enforcement_mode": basetypes.StringType{},
			"identity":         basetypes.StringType{},
			"identity_ids": basetypes.SetType{
				ElemType: types.StringType,
			},
			"non_compliance_messages": basetypes.SetType{
				ElemType: NonComplianceMessagesValue{}.Type(ctx),
			},
			"overrides": basetypes.ListType{
				ElemType: OverridesValue{}.Type(ctx),
			},
			"parameters": basetypes.StringType{},
			"resource_selectors": basetypes.ListType{
				ElemType: ResourceSelectorsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enforcement_mode": basetypes.StringType{},
		"identity":         basetypes.StringType{},
		"identity_ids": basetypes.SetType{
			ElemType: types.StringType,
		},
		"non_compliance_messages": basetypes.SetType{
			ElemType: NonComplianceMessagesValue{}.Type(ctx),
		},
		"overrides": basetypes.ListType{
			ElemType: OverridesValue{}.Type(ctx),
		},
		"parameters": basetypes.StringType{},
		"resource_selectors": basetypes.ListType{
			ElemType: ResourceSelectorsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enforcement_mode":        v.EnforcementMode,
			"identity":                v.Identity,
			"identity_ids":            identityIdsVal,
			"non_compliance_messages": nonComplianceMessages,
			"overrides":               overrides,
			"parameters":              v.Parameters,
			"resource_selectors":      resourceSelectors,
		})

	return objVal, diags
}

func (v PolicyAssignmentsValue) Equal(o attr.Value) bool {
	other, ok := o.(PolicyAssignmentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnforcementMode.Equal(other.EnforcementMode) {
		return false
	}

	if !v.Identity.Equal(other.Identity) {
		return false
	}

	if !v.IdentityIds.Equal(other.IdentityIds) {
		return false
	}

	if !v.NonComplianceMessages.Equal(other.NonComplianceMessages) {
		return false
	}

	if !v.Overrides.Equal(other.Overrides) {
		return false
	}

	if !v.Parameters.Equal(other.Parameters) {
		return false
	}

	if !v.ResourceSelectors.Equal(other.ResourceSelectors) {
		return false
	}

	return true
}

func (v PolicyAssignmentsValue) Type(ctx context.Context) attr.Type {
	return PolicyAssignmentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PolicyAssignmentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enforcement_mode": basetypes.StringType{},
		"identity":         basetypes.StringType{},
		"identity_ids": basetypes.SetType{
			ElemType: types.StringType,
		},
		"non_compliance_messages": basetypes.SetType{
			ElemType: NonComplianceMessagesValue{}.Type(ctx),
		},
		"overrides": basetypes.ListType{
			ElemType: OverridesValue{}.Type(ctx),
		},
		"parameters": basetypes.StringType{},
		"resource_selectors": basetypes.ListType{
			ElemType: ResourceSelectorsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = NonComplianceMessagesType{}

type NonComplianceMessagesType struct {
	basetypes.ObjectType
}

func (t NonComplianceMessagesType) Equal(o attr.Type) bool {
	other, ok := o.(NonComplianceMessagesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NonComplianceMessagesType) String() string {
	return "NonComplianceMessagesType"
}

func (t NonComplianceMessagesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return nil, diags
	}

	messageVal, ok := messageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be basetypes.StringValue, was: %T`, messageAttribute))
	}

	policyDefinitionReferenceIdAttribute, ok := attributes["policy_definition_reference_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_definition_reference_id is missing from object`)

		return nil, diags
	}

	policyDefinitionReferenceIdVal, ok := policyDefinitionReferenceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_definition_reference_id expected to be basetypes.StringValue, was: %T`, policyDefinitionReferenceIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NonComplianceMessagesValue{
		Message:                     messageVal,
		PolicyDefinitionReferenceId: policyDefinitionReferenceIdVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewNonComplianceMessagesValueNull() NonComplianceMessagesValue {
	return NonComplianceMessagesValue{
		state: attr.ValueStateNull,
	}
}

func NewNonComplianceMessagesValueUnknown() NonComplianceMessagesValue {
	return NonComplianceMessagesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNonComplianceMessagesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NonComplianceMessagesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NonComplianceMessagesValue Attribute Value",
				"While creating a NonComplianceMessagesValue value, a missing attribute value was detected. "+
					"A NonComplianceMessagesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NonComplianceMessagesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NonComplianceMessagesValue Attribute Type",
				"While creating a NonComplianceMessagesValue value, an invalid attribute value was detected. "+
					"A NonComplianceMessagesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NonComplianceMessagesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NonComplianceMessagesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NonComplianceMessagesValue Attribute Value",
				"While creating a NonComplianceMessagesValue value, an extra attribute value was detected. "+
					"A NonComplianceMessagesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NonComplianceMessagesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNonComplianceMessagesValueUnknown(), diags
	}

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return NewNonComplianceMessagesValueUnknown(), diags
	}

	messageVal, ok := messageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be basetypes.StringValue, was: %T`, messageAttribute))
	}

	policyDefinitionReferenceIdAttribute, ok := attributes["policy_definition_reference_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_definition_reference_id is missing from object`)

		return NewNonComplianceMessagesValueUnknown(), diags
	}

	policyDefinitionReferenceIdVal, ok := policyDefinitionReferenceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_definition_reference_id expected to be basetypes.StringValue, was: %T`, policyDefinitionReferenceIdAttribute))
	}

	if diags.HasError() {
		return NewNonComplianceMessagesValueUnknown(), diags
	}

	return NonComplianceMessagesValue{
		Message:                     messageVal,
		PolicyDefinitionReferenceId: policyDefinitionReferenceIdVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewNonComplianceMessagesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NonComplianceMessagesValue {
	object, diags := NewNonComplianceMessagesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNonComplianceMessagesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NonComplianceMessagesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNonComplianceMessagesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNonComplianceMessagesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNonComplianceMessagesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNonComplianceMessagesValueMust(NonComplianceMessagesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NonComplianceMessagesType) ValueType(ctx context.Context) attr.Value {
	return NonComplianceMessagesValue{}
}

var _ basetypes.ObjectValuable = NonComplianceMessagesValue{}

type NonComplianceMessagesValue struct {
	Message                     basetypes.StringValue `tfsdk:"message"`
	PolicyDefinitionReferenceId basetypes.StringValue `tfsdk:"policy_definition_reference_id"`
	state                       attr.ValueState
}

func (v NonComplianceMessagesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["policy_definition_reference_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Message.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message"] = val

		val, err = v.PolicyDefinitionReferenceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_definition_reference_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NonComplianceMessagesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NonComplianceMessagesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NonComplianceMessagesValue) String() string {
	return "NonComplianceMessagesValue"
}

func (v NonComplianceMessagesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"message":                        basetypes.StringType{},
		"policy_definition_reference_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"message":                        v.Message,
			"policy_definition_reference_id": v.PolicyDefinitionReferenceId,
		})

	return objVal, diags
}

func (v NonComplianceMessagesValue) Equal(o attr.Value) bool {
	other, ok := o.(NonComplianceMessagesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Message.Equal(other.Message) {
		return false
	}

	if !v.PolicyDefinitionReferenceId.Equal(other.PolicyDefinitionReferenceId) {
		return false
	}

	return true
}

func (v NonComplianceMessagesValue) Type(ctx context.Context) attr.Type {
	return NonComplianceMessagesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NonComplianceMessagesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"message":                        basetypes.StringType{},
		"policy_definition_reference_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OverridesType{}

type OverridesType struct {
	basetypes.ObjectType
}

func (t OverridesType) Equal(o attr.Type) bool {
	other, ok := o.(OverridesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverridesType) String() string {
	return "OverridesType"
}

func (t OverridesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	overrideSelectorsAttribute, ok := attributes["override_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_selectors is missing from object`)

		return nil, diags
	}

	overrideSelectorsVal, ok := overrideSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_selectors expected to be basetypes.ListValue, was: %T`, overrideSelectorsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverridesValue{
		Kind:              kindVal,
		OverrideSelectors: overrideSelectorsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewOverridesValueNull() OverridesValue {
	return OverridesValue{
		state: attr.ValueStateNull,
	}
}

func NewOverridesValueUnknown() OverridesValue {
	return OverridesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverridesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverridesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverridesValue Attribute Value",
				"While creating a OverridesValue value, a missing attribute value was detected. "+
					"A OverridesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverridesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverridesValue Attribute Type",
				"While creating a OverridesValue value, an invalid attribute value was detected. "+
					"A OverridesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverridesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverridesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverridesValue Attribute Value",
				"While creating a OverridesValue value, an extra attribute value was detected. "+
					"A OverridesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverridesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverridesValueUnknown(), diags
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewOverridesValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	overrideSelectorsAttribute, ok := attributes["override_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_selectors is missing from object`)

		return NewOverridesValueUnknown(), diags
	}

	overrideSelectorsVal, ok := overrideSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_selectors expected to be basetypes.ListValue, was: %T`, overrideSelectorsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewOverridesValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewOverridesValueUnknown(), diags
	}

	return OverridesValue{
		Kind:              kindVal,
		OverrideSelectors: overrideSelectorsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewOverridesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverridesValue {
	object, diags := NewOverridesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverridesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverridesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverridesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverridesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverridesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverridesValueMust(OverridesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverridesType) ValueType(ctx context.Context) attr.Value {
	return OverridesValue{}
}

var _ basetypes.ObjectValuable = OverridesValue{}

type OverridesValue struct {
	Kind              basetypes.StringValue `tfsdk:"kind"`
	OverrideSelectors basetypes.ListValue   `tfsdk:"override_selectors"`
	Value             basetypes.StringValue `tfsdk:"value"`
	state             attr.ValueState
}

func (v OverridesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["override_selectors"] = basetypes.ListType{
		ElemType: OverrideSelectorsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.OverrideSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["override_selectors"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverridesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverridesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverridesValue) String() string {
	return "OverridesValue"
}

func (v OverridesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	overrideSelectors := types.ListValueMust(
		OverrideSelectorsType{
			basetypes.ObjectType{
				AttrTypes: OverrideSelectorsValue{}.AttributeTypes(ctx),
			},
		},
		v.OverrideSelectors.Elements(),
	)

	if v.OverrideSelectors.IsNull() {
		overrideSelectors = types.ListNull(
			OverrideSelectorsType{
				basetypes.ObjectType{
					AttrTypes: OverrideSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OverrideSelectors.IsUnknown() {
		overrideSelectors = types.ListUnknown(
			OverrideSelectorsType{
				basetypes.ObjectType{
					AttrTypes: OverrideSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"kind": basetypes.StringType{},
		"override_selectors": basetypes.ListType{
			ElemType: OverrideSelectorsValue{}.Type(ctx),
		},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"kind":               v.Kind,
			"override_selectors": overrideSelectors,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v OverridesValue) Equal(o attr.Value) bool {
	other, ok := o.(OverridesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.OverrideSelectors.Equal(other.OverrideSelectors) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v OverridesValue) Type(ctx context.Context) attr.Type {
	return OverridesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverridesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"kind": basetypes.StringType{},
		"override_selectors": basetypes.ListType{
			ElemType: OverrideSelectorsValue{}.Type(ctx),
		},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OverrideSelectorsType{}

type OverrideSelectorsType struct {
	basetypes.ObjectType
}

func (t OverrideSelectorsType) Equal(o attr.Type) bool {
	other, ok := o.(OverrideSelectorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverrideSelectorsType) String() string {
	return "OverrideSelectorsType"
}

func (t OverrideSelectorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inAttribute, ok := attributes["in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in is missing from object`)

		return nil, diags
	}

	inVal, ok := inAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in expected to be basetypes.SetValue, was: %T`, inAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	notInAttribute, ok := attributes["not_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_in is missing from object`)

		return nil, diags
	}

	notInVal, ok := notInAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_in expected to be basetypes.SetValue, was: %T`, notInAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverrideSelectorsValue{
		In:    inVal,
		Kind:  kindVal,
		NotIn: notInVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOverrideSelectorsValueNull() OverrideSelectorsValue {
	return OverrideSelectorsValue{
		state: attr.ValueStateNull,
	}
}

func NewOverrideSelectorsValueUnknown() OverrideSelectorsValue {
	return OverrideSelectorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverrideSelectorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverrideSelectorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverrideSelectorsValue Attribute Value",
				"While creating a OverrideSelectorsValue value, a missing attribute value was detected. "+
					"A OverrideSelectorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverrideSelectorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverrideSelectorsValue Attribute Type",
				"While creating a OverrideSelectorsValue value, an invalid attribute value was detected. "+
					"A OverrideSelectorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverrideSelectorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverrideSelectorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverrideSelectorsValue Attribute Value",
				"While creating a OverrideSelectorsValue value, an extra attribute value was detected. "+
					"A OverrideSelectorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverrideSelectorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverrideSelectorsValueUnknown(), diags
	}

	inAttribute, ok := attributes["in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in is missing from object`)

		return NewOverrideSelectorsValueUnknown(), diags
	}

	inVal, ok := inAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in expected to be basetypes.SetValue, was: %T`, inAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewOverrideSelectorsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	notInAttribute, ok := attributes["not_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_in is missing from object`)

		return NewOverrideSelectorsValueUnknown(), diags
	}

	notInVal, ok := notInAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_in expected to be basetypes.SetValue, was: %T`, notInAttribute))
	}

	if diags.HasError() {
		return NewOverrideSelectorsValueUnknown(), diags
	}

	return OverrideSelectorsValue{
		In:    inVal,
		Kind:  kindVal,
		NotIn: notInVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOverrideSelectorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverrideSelectorsValue {
	object, diags := NewOverrideSelectorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverrideSelectorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverrideSelectorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverrideSelectorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverrideSelectorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverrideSelectorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverrideSelectorsValueMust(OverrideSelectorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverrideSelectorsType) ValueType(ctx context.Context) attr.Value {
	return OverrideSelectorsValue{}
}

var _ basetypes.ObjectValuable = OverrideSelectorsValue{}

type OverrideSelectorsValue struct {
	In    basetypes.SetValue    `tfsdk:"in"`
	Kind  basetypes.StringValue `tfsdk:"kind"`
	NotIn basetypes.SetValue    `tfsdk:"not_in"`
	state attr.ValueState
}

func (v OverrideSelectorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["in"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_in"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.In.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["in"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.NotIn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_in"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverrideSelectorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverrideSelectorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverrideSelectorsValue) String() string {
	return "OverrideSelectorsValue"
}

func (v OverrideSelectorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	inVal, d := types.SetValue(types.StringType, v.In.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"in": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kind": basetypes.StringType{},
			"not_in": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	notInVal, d := types.SetValue(types.StringType, v.NotIn.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"in": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kind": basetypes.StringType{},
			"not_in": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"in": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kind": basetypes.StringType{},
		"not_in": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"in":     inVal,
			"kind":   v.Kind,
			"not_in": notInVal,
		})

	return objVal, diags
}

func (v OverrideSelectorsValue) Equal(o attr.Value) bool {
	other, ok := o.(OverrideSelectorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.In.Equal(other.In) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.NotIn.Equal(other.NotIn) {
		return false
	}

	return true
}

func (v OverrideSelectorsValue) Type(ctx context.Context) attr.Type {
	return OverrideSelectorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverrideSelectorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"in": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kind": basetypes.StringType{},
		"not_in": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ResourceSelectorsType{}

type ResourceSelectorsType struct {
	basetypes.ObjectType
}

func (t ResourceSelectorsType) Equal(o attr.Type) bool {
	other, ok := o.(ResourceSelectorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourceSelectorsType) String() string {
	return "ResourceSelectorsType"
}

func (t ResourceSelectorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceSelectorSelectorsAttribute, ok := attributes["resource_selector_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_selector_selectors is missing from object`)

		return nil, diags
	}

	resourceSelectorSelectorsVal, ok := resourceSelectorSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_selector_selectors expected to be basetypes.ListValue, was: %T`, resourceSelectorSelectorsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourceSelectorsValue{
		Name:                      nameVal,
		ResourceSelectorSelectors: resourceSelectorSelectorsVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewResourceSelectorsValueNull() ResourceSelectorsValue {
	return ResourceSelectorsValue{
		state: attr.ValueStateNull,
	}
}

func NewResourceSelectorsValueUnknown() ResourceSelectorsValue {
	return ResourceSelectorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourceSelectorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourceSelectorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourceSelectorsValue Attribute Value",
				"While creating a ResourceSelectorsValue value, a missing attribute value was detected. "+
					"A ResourceSelectorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceSelectorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourceSelectorsValue Attribute Type",
				"While creating a ResourceSelectorsValue value, an invalid attribute value was detected. "+
					"A ResourceSelectorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceSelectorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourceSelectorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourceSelectorsValue Attribute Value",
				"While creating a ResourceSelectorsValue value, an extra attribute value was detected. "+
					"A ResourceSelectorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourceSelectorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourceSelectorsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewResourceSelectorsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceSelectorSelectorsAttribute, ok := attributes["resource_selector_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_selector_selectors is missing from object`)

		return NewResourceSelectorsValueUnknown(), diags
	}

	resourceSelectorSelectorsVal, ok := resourceSelectorSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_selector_selectors expected to be basetypes.ListValue, was: %T`, resourceSelectorSelectorsAttribute))
	}

	if diags.HasError() {
		return NewResourceSelectorsValueUnknown(), diags
	}

	return ResourceSelectorsValue{
		Name:                      nameVal,
		ResourceSelectorSelectors: resourceSelectorSelectorsVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewResourceSelectorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourceSelectorsValue {
	object, diags := NewResourceSelectorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourceSelectorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourceSelectorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourceSelectorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourceSelectorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourceSelectorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourceSelectorsValueMust(ResourceSelectorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourceSelectorsType) ValueType(ctx context.Context) attr.Value {
	return ResourceSelectorsValue{}
}

var _ basetypes.ObjectValuable = ResourceSelectorsValue{}

type ResourceSelectorsValue struct {
	Name                      basetypes.StringValue `tfsdk:"name"`
	ResourceSelectorSelectors basetypes.ListValue   `tfsdk:"resource_selector_selectors"`
	state                     attr.ValueState
}

func (v ResourceSelectorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_selector_selectors"] = basetypes.ListType{
		ElemType: ResourceSelectorSelectorsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ResourceSelectorSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_selector_selectors"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourceSelectorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourceSelectorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourceSelectorsValue) String() string {
	return "ResourceSelectorsValue"
}

func (v ResourceSelectorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	resourceSelectorSelectors := types.ListValueMust(
		ResourceSelectorSelectorsType{
			basetypes.ObjectType{
				AttrTypes: ResourceSelectorSelectorsValue{}.AttributeTypes(ctx),
			},
		},
		v.ResourceSelectorSelectors.Elements(),
	)

	if v.ResourceSelectorSelectors.IsNull() {
		resourceSelectorSelectors = types.ListNull(
			ResourceSelectorSelectorsType{
				basetypes.ObjectType{
					AttrTypes: ResourceSelectorSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ResourceSelectorSelectors.IsUnknown() {
		resourceSelectorSelectors = types.ListUnknown(
			ResourceSelectorSelectorsType{
				basetypes.ObjectType{
					AttrTypes: ResourceSelectorSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"resource_selector_selectors": basetypes.ListType{
			ElemType: ResourceSelectorSelectorsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":                        v.Name,
			"resource_selector_selectors": resourceSelectorSelectors,
		})

	return objVal, diags
}

func (v ResourceSelectorsValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourceSelectorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ResourceSelectorSelectors.Equal(other.ResourceSelectorSelectors) {
		return false
	}

	return true
}

func (v ResourceSelectorsValue) Type(ctx context.Context) attr.Type {
	return ResourceSelectorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourceSelectorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"resource_selector_selectors": basetypes.ListType{
			ElemType: ResourceSelectorSelectorsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ResourceSelectorSelectorsType{}

type ResourceSelectorSelectorsType struct {
	basetypes.ObjectType
}

func (t ResourceSelectorSelectorsType) Equal(o attr.Type) bool {
	other, ok := o.(ResourceSelectorSelectorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourceSelectorSelectorsType) String() string {
	return "ResourceSelectorSelectorsType"
}

func (t ResourceSelectorSelectorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inAttribute, ok := attributes["in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in is missing from object`)

		return nil, diags
	}

	inVal, ok := inAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in expected to be basetypes.SetValue, was: %T`, inAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	notInAttribute, ok := attributes["not_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_in is missing from object`)

		return nil, diags
	}

	notInVal, ok := notInAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_in expected to be basetypes.SetValue, was: %T`, notInAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourceSelectorSelectorsValue{
		In:    inVal,
		Kind:  kindVal,
		NotIn: notInVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewResourceSelectorSelectorsValueNull() ResourceSelectorSelectorsValue {
	return ResourceSelectorSelectorsValue{
		state: attr.ValueStateNull,
	}
}

func NewResourceSelectorSelectorsValueUnknown() ResourceSelectorSelectorsValue {
	return ResourceSelectorSelectorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourceSelectorSelectorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourceSelectorSelectorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourceSelectorSelectorsValue Attribute Value",
				"While creating a ResourceSelectorSelectorsValue value, a missing attribute value was detected. "+
					"A ResourceSelectorSelectorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceSelectorSelectorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourceSelectorSelectorsValue Attribute Type",
				"While creating a ResourceSelectorSelectorsValue value, an invalid attribute value was detected. "+
					"A ResourceSelectorSelectorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceSelectorSelectorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourceSelectorSelectorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourceSelectorSelectorsValue Attribute Value",
				"While creating a ResourceSelectorSelectorsValue value, an extra attribute value was detected. "+
					"A ResourceSelectorSelectorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourceSelectorSelectorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	inAttribute, ok := attributes["in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in is missing from object`)

		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	inVal, ok := inAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in expected to be basetypes.SetValue, was: %T`, inAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	notInAttribute, ok := attributes["not_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_in is missing from object`)

		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	notInVal, ok := notInAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_in expected to be basetypes.SetValue, was: %T`, notInAttribute))
	}

	if diags.HasError() {
		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	return ResourceSelectorSelectorsValue{
		In:    inVal,
		Kind:  kindVal,
		NotIn: notInVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewResourceSelectorSelectorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourceSelectorSelectorsValue {
	object, diags := NewResourceSelectorSelectorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourceSelectorSelectorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourceSelectorSelectorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourceSelectorSelectorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourceSelectorSelectorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourceSelectorSelectorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourceSelectorSelectorsValueMust(ResourceSelectorSelectorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourceSelectorSelectorsType) ValueType(ctx context.Context) attr.Value {
	return ResourceSelectorSelectorsValue{}
}

var _ basetypes.ObjectValuable = ResourceSelectorSelectorsValue{}

type ResourceSelectorSelectorsValue struct {
	In    basetypes.SetValue    `tfsdk:"in"`
	Kind  basetypes.StringValue `tfsdk:"kind"`
	NotIn basetypes.SetValue    `tfsdk:"not_in"`
	state attr.ValueState
}

func (v ResourceSelectorSelectorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["in"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_in"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.In.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["in"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.NotIn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_in"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourceSelectorSelectorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourceSelectorSelectorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourceSelectorSelectorsValue) String() string {
	return "ResourceSelectorSelectorsValue"
}

func (v ResourceSelectorSelectorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	inVal, d := types.SetValue(types.StringType, v.In.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"in": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kind": basetypes.StringType{},
			"not_in": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	notInVal, d := types.SetValue(types.StringType, v.NotIn.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"in": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kind": basetypes.StringType{},
			"not_in": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"in": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kind": basetypes.StringType{},
		"not_in": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"in":     inVal,
			"kind":   v.Kind,
			"not_in": notInVal,
		})

	return objVal, diags
}

func (v ResourceSelectorSelectorsValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourceSelectorSelectorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.In.Equal(other.In) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.NotIn.Equal(other.NotIn) {
		return false
	}

	return true
}

func (v ResourceSelectorSelectorsValue) Type(ctx context.Context) attr.Type {
	return ResourceSelectorSelectorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourceSelectorSelectorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"in": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kind": basetypes.StringType{},
		"not_in": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = PolicyRoleAssignmentsType{}

type PolicyRoleAssignmentsType struct {
	basetypes.ObjectType
}

func (t PolicyRoleAssignmentsType) Equal(o attr.Type) bool {
	other, ok := o.(PolicyRoleAssignmentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PolicyRoleAssignmentsType) String() string {
	return "PolicyRoleAssignmentsType"
}

func (t PolicyRoleAssignmentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	managementGroupIdAttribute, ok := attributes["management_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`management_group_id is missing from object`)

		return nil, diags
	}

	managementGroupIdVal, ok := managementGroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`management_group_id expected to be basetypes.StringValue, was: %T`, managementGroupIdAttribute))
	}

	policyAssignmentNameAttribute, ok := attributes["policy_assignment_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignment_name is missing from object`)

		return nil, diags
	}

	policyAssignmentNameVal, ok := policyAssignmentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignment_name expected to be basetypes.StringValue, was: %T`, policyAssignmentNameAttribute))
	}

	roleDefinitionIdAttribute, ok := attributes["role_definition_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_definition_id is missing from object`)

		return nil, diags
	}

	roleDefinitionIdVal, ok := roleDefinitionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_definition_id expected to be basetypes.StringValue, was: %T`, roleDefinitionIdAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PolicyRoleAssignmentsValue{
		ManagementGroupId:    managementGroupIdVal,
		PolicyAssignmentName: policyAssignmentNameVal,
		RoleDefinitionId:     roleDefinitionIdVal,
		Scope:                scopeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPolicyRoleAssignmentsValueNull() PolicyRoleAssignmentsValue {
	return PolicyRoleAssignmentsValue{
		state: attr.ValueStateNull,
	}
}

func NewPolicyRoleAssignmentsValueUnknown() PolicyRoleAssignmentsValue {
	return PolicyRoleAssignmentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPolicyRoleAssignmentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PolicyRoleAssignmentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PolicyRoleAssignmentsValue Attribute Value",
				"While creating a PolicyRoleAssignmentsValue value, a missing attribute value was detected. "+
					"A PolicyRoleAssignmentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyRoleAssignmentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PolicyRoleAssignmentsValue Attribute Type",
				"While creating a PolicyRoleAssignmentsValue value, an invalid attribute value was detected. "+
					"A PolicyRoleAssignmentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyRoleAssignmentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PolicyRoleAssignmentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PolicyRoleAssignmentsValue Attribute Value",
				"While creating a PolicyRoleAssignmentsValue value, an extra attribute value was detected. "+
					"A PolicyRoleAssignmentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PolicyRoleAssignmentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPolicyRoleAssignmentsValueUnknown(), diags
	}

	managementGroupIdAttribute, ok := attributes["management_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`management_group_id is missing from object`)

		return NewPolicyRoleAssignmentsValueUnknown(), diags
	}

	managementGroupIdVal, ok := managementGroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`management_group_id expected to be basetypes.StringValue, was: %T`, managementGroupIdAttribute))
	}

	policyAssignmentNameAttribute, ok := attributes["policy_assignment_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignment_name is missing from object`)

		return NewPolicyRoleAssignmentsValueUnknown(), diags
	}

	policyAssignmentNameVal, ok := policyAssignmentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignment_name expected to be basetypes.StringValue, was: %T`, policyAssignmentNameAttribute))
	}

	roleDefinitionIdAttribute, ok := attributes["role_definition_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_definition_id is missing from object`)

		return NewPolicyRoleAssignmentsValueUnknown(), diags
	}

	roleDefinitionIdVal, ok := roleDefinitionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_definition_id expected to be basetypes.StringValue, was: %T`, roleDefinitionIdAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewPolicyRoleAssignmentsValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return NewPolicyRoleAssignmentsValueUnknown(), diags
	}

	return PolicyRoleAssignmentsValue{
		ManagementGroupId:    managementGroupIdVal,
		PolicyAssignmentName: policyAssignmentNameVal,
		RoleDefinitionId:     roleDefinitionIdVal,
		Scope:                scopeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPolicyRoleAssignmentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PolicyRoleAssignmentsValue {
	object, diags := NewPolicyRoleAssignmentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPolicyRoleAssignmentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PolicyRoleAssignmentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPolicyRoleAssignmentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPolicyRoleAssignmentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPolicyRoleAssignmentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPolicyRoleAssignmentsValueMust(PolicyRoleAssignmentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PolicyRoleAssignmentsType) ValueType(ctx context.Context) attr.Value {
	return PolicyRoleAssignmentsValue{}
}

var _ basetypes.ObjectValuable = PolicyRoleAssignmentsValue{}

type PolicyRoleAssignmentsValue struct {
	ManagementGroupId    basetypes.StringValue `tfsdk:"management_group_id"`
	PolicyAssignmentName basetypes.StringValue `tfsdk:"policy_assignment_name"`
	RoleDefinitionId     basetypes.StringValue `tfsdk:"role_definition_id"`
	Scope                basetypes.StringValue `tfsdk:"scope"`
	state                attr.ValueState
}

func (v PolicyRoleAssignmentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["management_group_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["policy_assignment_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role_definition_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ManagementGroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["management_group_id"] = val

		val, err = v.PolicyAssignmentName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_assignment_name"] = val

		val, err = v.RoleDefinitionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_definition_id"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PolicyRoleAssignmentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PolicyRoleAssignmentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PolicyRoleAssignmentsValue) String() string {
	return "PolicyRoleAssignmentsValue"
}

func (v PolicyRoleAssignmentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"management_group_id":    basetypes.StringType{},
		"policy_assignment_name": basetypes.StringType{},
		"role_definition_id":     basetypes.StringType{},
		"scope":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"management_group_id":    v.ManagementGroupId,
			"policy_assignment_name": v.PolicyAssignmentName,
			"role_definition_id":     v.RoleDefinitionId,
			"scope":                  v.Scope,
		})

	return objVal, diags
}

func (v PolicyRoleAssignmentsValue) Equal(o attr.Value) bool {
	other, ok := o.(PolicyRoleAssignmentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ManagementGroupId.Equal(other.ManagementGroupId) {
		return false
	}

	if !v.PolicyAssignmentName.Equal(other.PolicyAssignmentName) {
		return false
	}

	if !v.RoleDefinitionId.Equal(other.RoleDefinitionId) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	return true
}

func (v PolicyRoleAssignmentsValue) Type(ctx context.Context) attr.Type {
	return PolicyRoleAssignmentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PolicyRoleAssignmentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"management_group_id":    basetypes.StringType{},
		"policy_assignment_name": basetypes.StringType{},
		"role_definition_id":     basetypes.StringType{},
		"scope":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TimeoutsType{}

type TimeoutsType struct {
	basetypes.ObjectType
}

func (t TimeoutsType) Equal(o attr.Type) bool {
	other, ok := o.(TimeoutsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimeoutsType) String() string {
	return "TimeoutsType"
}

func (t TimeoutsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	readAttribute, ok := attributes["read"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read is missing from object`)

		return nil, diags
	}

	readVal, ok := readAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read expected to be basetypes.StringValue, was: %T`, readAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TimeoutsValue{
		Read:  readVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTimeoutsValueNull() TimeoutsValue {
	return TimeoutsValue{
		state: attr.ValueStateNull,
	}
}

func NewTimeoutsValueUnknown() TimeoutsValue {
	return TimeoutsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimeoutsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimeoutsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimeoutsValue Attribute Value",
				"While creating a TimeoutsValue value, a missing attribute value was detected. "+
					"A TimeoutsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimeoutsValue Attribute Type",
				"While creating a TimeoutsValue value, an invalid attribute value was detected. "+
					"A TimeoutsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimeoutsValue Attribute Value",
				"While creating a TimeoutsValue value, an extra attribute value was detected. "+
					"A TimeoutsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimeoutsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimeoutsValueUnknown(), diags
	}

	readAttribute, ok := attributes["read"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read is missing from object`)

		return NewTimeoutsValueUnknown(), diags
	}

	readVal, ok := readAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read expected to be basetypes.StringValue, was: %T`, readAttribute))
	}

	if diags.HasError() {
		return NewTimeoutsValueUnknown(), diags
	}

	return TimeoutsValue{
		Read:  readVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTimeoutsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimeoutsValue {
	object, diags := NewTimeoutsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimeoutsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimeoutsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimeoutsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimeoutsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimeoutsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimeoutsValueMust(TimeoutsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimeoutsType) ValueType(ctx context.Context) attr.Value {
	return TimeoutsValue{}
}

var _ basetypes.ObjectValuable = TimeoutsValue{}

type TimeoutsValue struct {
	Read  basetypes.StringValue `tfsdk:"read"`
	state attr.ValueState
}

func (v TimeoutsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["read"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Read.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimeoutsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimeoutsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimeoutsValue) String() string {
	return "TimeoutsValue"
}

func (v TimeoutsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"read": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"read": v.Read,
		})

	return objVal, diags
}

func (v TimeoutsValue) Equal(o attr.Value) bool {
	other, ok := o.(TimeoutsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Read.Equal(other.Read) {
		return false
	}

	return true
}

func (v TimeoutsValue) Type(ctx context.Context) attr.Type {
	return TimeoutsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimeoutsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"read": basetypes.StringType{},
	}
}
