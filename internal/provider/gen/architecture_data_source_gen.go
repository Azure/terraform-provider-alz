// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package gen

import (
	"context"
	"fmt"
	"github.com/Azure/terraform-provider-alz/internal/alztypes"
	"github.com/Azure/terraform-provider-alz/internal/alzvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ArchitectureDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
				MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
			},
			"location": schema.StringAttribute{
				Required:            true,
				Description:         "The Azure region used as a default for resources.",
				MarkdownDescription: "The Azure region used as a default for resources.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"management_groups": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"display_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The display name of the management group.",
							MarkdownDescription: "The display name of the management group.",
						},
						"exists": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether the management group already exists or not. Used to determine if the management group should be created or just have policy/role resources created within.",
							MarkdownDescription: "Whether the management group already exists or not. Used to determine if the management group should be created or just have policy/role resources created within.",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "The id of the management group. This the last segment of the resource id.",
							MarkdownDescription: "The id of the management group. This the last segment of the resource id.",
						},
						"level": schema.NumberAttribute{
							Computed:            true,
							Description:         "The level of the management group in the hierarchy, relative to the supplied root management group. The level starts at zero.",
							MarkdownDescription: "The level of the management group in the hierarchy, relative to the supplied root management group. The level starts at zero.",
						},
						"policy_assignments": schema.MapAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "The policy assignments to apply to the management group. The key is the policy assignment name, and the value is the policy assignment JSON as a string.",
							MarkdownDescription: "The policy assignments to apply to the management group. The key is the policy assignment name, and the value is the policy assignment JSON as a string.",
						},
						"policy_definitions": schema.MapAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "The policy definitions to apply to the management group. The key is the policy definition name, and the value is the policy definition JSON as a string.",
							MarkdownDescription: "The policy definitions to apply to the management group. The key is the policy definition name, and the value is the policy definition JSON as a string.",
						},
						"policy_set_definitions": schema.MapAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "The policy set definitions to apply to the management group. The key is the policy set definition name, and the value is the policy set definition JSON as a string.",
							MarkdownDescription: "The policy set definitions to apply to the management group. The key is the policy set definition name, and the value is the policy set definition JSON as a string.",
						},
						"role_definitions": schema.MapAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "The role definitions to apply to the management group. The key is the role definition name, and the value is the role definition JSON as a string.",
							MarkdownDescription: "The role definitions to apply to the management group. The key is the role definition name, and the value is the role definition JSON as a string.",
						},
					},
					CustomType: ManagementGroupsType{
						ObjectType: types.ObjectType{
							AttrTypes: ManagementGroupsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "This is a list of objects pertaining to the tier of management groups to be deployed (relative to the supplied root management group id). Use the `level` attribute to specify the tier of management groups to deploy.",
				MarkdownDescription: "This is a list of objects pertaining to the tier of management groups to be deployed (relative to the supplied root management group id). Use the `level` attribute to specify the tier of management groups to deploy.",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the architecture to deploy.",
				MarkdownDescription: "The name of the architecture to deploy.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"policy_assignments_to_modify": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"policy_assignments": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"enforcement_mode": schema.StringAttribute{
										Optional:            true,
										Description:         "The enforcement mode for the policy assignment. Valid values are `Default` and `DoNotEnforce`.",
										MarkdownDescription: "The enforcement mode for the policy assignment. Valid values are `Default` and `DoNotEnforce`.",
										Validators: []validator.String{
											stringvalidator.OneOf("Default", "DoNotEnforce"),
										},
									},
									"identity": schema.StringAttribute{
										Optional:            true,
										Description:         "The identity type. Must be one of `SystemAssigned` or `UserAssigned`.",
										MarkdownDescription: "The identity type. Must be one of `SystemAssigned` or `UserAssigned`.",
										Validators: []validator.String{
											stringvalidator.OneOf("SystemAssigned", "UserAssigned"),
										},
									},
									"identity_ids": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A set of zero or one identity ids to assign to the policy assignment. Required if `identity` is `UserAssigned`. **Do not** pass in computed values, instead construct the resource id yourself.",
										MarkdownDescription: "A set of zero or one identity ids to assign to the policy assignment. Required if `identity` is `UserAssigned`. **Do not** pass in computed values, instead construct the resource id yourself.",
										Validators: []validator.Set{
											setvalidator.ValueStringsAre(alzvalidators.ArmTypeResourceId("Microsoft.ManagedIdentity", "userAssignedIdentities")),
											setvalidator.AlsoRequires(path.MatchRelative().AtParent().AtName("identity")),
											setvalidator.SizeBetween(0, 1),
										},
									},
									"non_compliance_message": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"message": schema.StringAttribute{
												Required:            true,
												Description:         "The non-compliance message to use for the policy assignment.",
												MarkdownDescription: "The non-compliance message to use for the policy assignment.",
											},
											"policy_definition_reference_id": schema.StringAttribute{
												Optional:            true,
												Description:         "The policy definition reference id (not the resource id) to use for the non compliance message. This references the definition within the policy set.",
												MarkdownDescription: "The policy definition reference id (not the resource id) to use for the non compliance message. This references the definition within the policy set.",
											},
										},
										CustomType: NonComplianceMessageType{
											ObjectType: types.ObjectType{
												AttrTypes: NonComplianceMessageValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "The non-compliance messages to use for the policy assignment.",
										MarkdownDescription: "The non-compliance messages to use for the policy assignment.",
									},
									"overrides": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"kind": schema.StringAttribute{
													Required:            true,
													Description:         "The property the assignment will override. The supported kind is `policyEffect`.",
													MarkdownDescription: "The property the assignment will override. The supported kind is `policyEffect`.",
													Validators: []validator.String{
														stringvalidator.OneOf("policyEffect"),
													},
												},
												"override_selectors": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"in": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "The list of values that the selector will match. Conflicts with `not_in`.",
																MarkdownDescription: "The list of values that the selector will match. Conflicts with `not_in`.",
																Validators: []validator.Set{
																	setvalidator.SizeAtMost(50),
																	setvalidator.ConflictsWith(path.MatchRelative().AtParent().AtName("not_in")),
																},
															},
															"kind": schema.StringAttribute{
																Required:            true,
																Description:         "The property of a selector that describes what characteristic will narrow down the scope of the override. Allowed value for kind: `policyEffect` is: `policyDefinitionReferenceId`.",
																MarkdownDescription: "The property of a selector that describes what characteristic will narrow down the scope of the override. Allowed value for kind: `policyEffect` is: `policyDefinitionReferenceId`.",
																Validators: []validator.String{
																	stringvalidator.OneOf("policyDefinitionReferenceId"),
																},
															},
															"not_in": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "The list of values that the selector will not match. Conflicts with `in`.",
																MarkdownDescription: "The list of values that the selector will not match. Conflicts with `in`.",
																Validators: []validator.Set{
																	setvalidator.SizeAtMost(50),
																	setvalidator.ConflictsWith(path.MatchRelative().AtParent().AtName("not_in")),
																},
															},
														},
														CustomType: OverrideSelectorsType{
															ObjectType: types.ObjectType{
																AttrTypes: OverrideSelectorsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "The selectors to use for the override.",
													MarkdownDescription: "The selectors to use for the override.",
												},
												"value": schema.StringAttribute{
													Required:            true,
													Description:         "The new value which will override the existing value. The supported values are: `addToNetworkGroup`, `append`, `audit`, `auditIfNotExists`, `deny`, `denyAction`, `deployIfNotExists`, `disabled`, `manual`, `modify`, `mutate`. <https://learn.microsoft.com/azure/governance/policy/concepts/effects>",
													MarkdownDescription: "The new value which will override the existing value. The supported values are: `addToNetworkGroup`, `append`, `audit`, `auditIfNotExists`, `deny`, `denyAction`, `deployIfNotExists`, `disabled`, `manual`, `modify`, `mutate`. <https://learn.microsoft.com/azure/governance/policy/concepts/effects>",
													Validators: []validator.String{
														stringvalidator.OneOf("addToNetworkGroup", "append", "audit", "auditIfNotExists", "deny", "denyAction", "deployIfNotExists", "disabled", "manual", "modify", "mutate"),
													},
												},
											},
											CustomType: OverridesType{
												ObjectType: types.ObjectType{
													AttrTypes: OverridesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "The overrides for this policy assignment. There are a maximum of 10 overrides allowed per assignment. If specified here the overrides will replace the existing overrides.",
										MarkdownDescription: "The overrides for this policy assignment. There are a maximum of 10 overrides allowed per assignment. If specified here the overrides will replace the existing overrides.",
										Validators: []validator.List{
											listvalidator.SizeAtMost(10),
											listvalidator.UniqueValues(),
										},
									},
									"parameters": schema.StringAttribute{
										CustomType:          alztypes.PolicyParameterType{},
										Optional:            true,
										Description:         "The parameters to use for the policy assignment. **Note:** This is a JSON string, and not a map. This is because the parameter values have different types, which confuses the type system used by the provider sdk. Use `jsonencode()` to construct the map. The map keys must be strings, the values are `any` type. Example: `jsonencode({\"param1\": \"value1\", \"param2\": 2})`",
										MarkdownDescription: "The parameters to use for the policy assignment. **Note:** This is a JSON string, and not a map. This is because the parameter values have different types, which confuses the type system used by the provider sdk. Use `jsonencode()` to construct the map. The map keys must be strings, the values are `any` type. Example: `jsonencode({\"param1\": \"value1\", \"param2\": 2})`",
									},
									"resource_selectors": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:            true,
													Description:         "The name of the resource selector. The name must be unique within the assignment.",
													MarkdownDescription: "The name of the resource selector. The name must be unique within the assignment.",
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"resource_selector_selectors": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"in": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "The list of values that the selector will match. Conflicts with `not_in`.",
																MarkdownDescription: "The list of values that the selector will match. Conflicts with `not_in`.",
																Validators: []validator.Set{
																	setvalidator.SizeAtMost(50),
																	setvalidator.ConflictsWith(path.MatchRelative().AtParent().AtName("not_in")),
																},
															},
															"kind": schema.StringAttribute{
																Required:            true,
																Description:         "The property of a selector that describes what characteristic will narrow down the set of evaluated resources. Each kind can only be used once in a single resource selector. Allowed values are: `resourceLocation`, `resourceType`, `resourceWithoutLocation`. `resourceWithoutLocation` cannot be used in the same resource selector as `resourceLocation`.",
																MarkdownDescription: "The property of a selector that describes what characteristic will narrow down the set of evaluated resources. Each kind can only be used once in a single resource selector. Allowed values are: `resourceLocation`, `resourceType`, `resourceWithoutLocation`. `resourceWithoutLocation` cannot be used in the same resource selector as `resourceLocation`.",
																Validators: []validator.String{
																	stringvalidator.OneOf("resourceLocation", "resourceType", "resourceWithoutLocation"),
																},
															},
															"not_in": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "The list of values that the selector will not match. Conflicts with `in`.",
																MarkdownDescription: "The list of values that the selector will not match. Conflicts with `in`.",
																Validators: []validator.Set{
																	setvalidator.SizeAtMost(50),
																	setvalidator.ConflictsWith(path.MatchRelative().AtParent().AtName("not_in")),
																},
															},
														},
														CustomType: ResourceSelectorSelectorsType{
															ObjectType: types.ObjectType{
																AttrTypes: ResourceSelectorSelectorsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "The selectors to use for the resource selector.",
													MarkdownDescription: "The selectors to use for the resource selector.",
												},
											},
											CustomType: ResourceSelectorsType{
												ObjectType: types.ObjectType{
													AttrTypes: ResourceSelectorsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "The resource selectors to use for the policy assignment. A maximum of 10 resource selectors are allowed per assignment. If specified here the resource selectors will replace any existing resource selectors.",
										MarkdownDescription: "The resource selectors to use for the policy assignment. A maximum of 10 resource selectors are allowed per assignment. If specified here the resource selectors will replace any existing resource selectors.",
										Validators: []validator.List{
											listvalidator.SizeAtMost(10),
											listvalidator.UniqueValues(),
										},
									},
								},
								CustomType: PolicyAssignmentsType{
									ObjectType: types.ObjectType{
										AttrTypes: PolicyAssignmentsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "A map of policy assignments to modify. The key is the policy assignment name, and the value is an object containing the modifications to make.",
							MarkdownDescription: "A map of policy assignments to modify. The key is the policy assignment name, and the value is an object containing the modifications to make.",
						},
					},
					CustomType: PolicyAssignmentsToModifyType{
						ObjectType: types.ObjectType{
							AttrTypes: PolicyAssignmentsToModifyValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "A mested map of policy assignments to modify. The key is the management group id, and the value is an object with a single attribute, `policy_assignments`. This is another map.",
				MarkdownDescription: "A mested map of policy assignments to modify. The key is the management group id, and the value is an object with a single attribute, `policy_assignments`. This is another map.",
			},
			"root_management_group_id": schema.StringAttribute{
				Required:            true,
				Description:         "The root management group id under which to deploy the architecture.",
				MarkdownDescription: "The root management group id under which to deploy the architecture.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
		},
		Description:         "The architecture data source provides the information required to deploy an ALZ management group hierarchy, including policy and additional role assignment detail.",
		MarkdownDescription: "The architecture data source provides the information required to deploy an ALZ management group hierarchy, including policy and additional role assignment detail.",
	}
}

type ArchitectureModel struct {
	Id                        types.String `tfsdk:"id"`
	Location                  types.String `tfsdk:"location"`
	ManagementGroups          types.List   `tfsdk:"management_groups"`
	Name                      types.String `tfsdk:"name"`
	PolicyAssignmentsToModify types.Map    `tfsdk:"policy_assignments_to_modify"`
	RootManagementGroupId     types.String `tfsdk:"root_management_group_id"`
}

var _ basetypes.ObjectTypable = ManagementGroupsType{}

type ManagementGroupsType struct {
	basetypes.ObjectType
}

func (t ManagementGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(ManagementGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ManagementGroupsType) String() string {
	return "ManagementGroupsType"
}

func (t ManagementGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	existsAttribute, ok := attributes["exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exists is missing from object`)

		return nil, diags
	}

	existsVal, ok := existsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exists expected to be basetypes.BoolValue, was: %T`, existsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	levelAttribute, ok := attributes["level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`level is missing from object`)

		return nil, diags
	}

	levelVal, ok := levelAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`level expected to be basetypes.NumberValue, was: %T`, levelAttribute))
	}

	policyAssignmentsAttribute, ok := attributes["policy_assignments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignments is missing from object`)

		return nil, diags
	}

	policyAssignmentsVal, ok := policyAssignmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignments expected to be basetypes.MapValue, was: %T`, policyAssignmentsAttribute))
	}

	policyDefinitionsAttribute, ok := attributes["policy_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_definitions is missing from object`)

		return nil, diags
	}

	policyDefinitionsVal, ok := policyDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_definitions expected to be basetypes.MapValue, was: %T`, policyDefinitionsAttribute))
	}

	policySetDefinitionsAttribute, ok := attributes["policy_set_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_set_definitions is missing from object`)

		return nil, diags
	}

	policySetDefinitionsVal, ok := policySetDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_set_definitions expected to be basetypes.MapValue, was: %T`, policySetDefinitionsAttribute))
	}

	roleDefinitionsAttribute, ok := attributes["role_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_definitions is missing from object`)

		return nil, diags
	}

	roleDefinitionsVal, ok := roleDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_definitions expected to be basetypes.MapValue, was: %T`, roleDefinitionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ManagementGroupsValue{
		DisplayName:          displayNameVal,
		Exists:               existsVal,
		Id:                   idVal,
		Level:                levelVal,
		PolicyAssignments:    policyAssignmentsVal,
		PolicyDefinitions:    policyDefinitionsVal,
		PolicySetDefinitions: policySetDefinitionsVal,
		RoleDefinitions:      roleDefinitionsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewManagementGroupsValueNull() ManagementGroupsValue {
	return ManagementGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewManagementGroupsValueUnknown() ManagementGroupsValue {
	return ManagementGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewManagementGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ManagementGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ManagementGroupsValue Attribute Value",
				"While creating a ManagementGroupsValue value, a missing attribute value was detected. "+
					"A ManagementGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ManagementGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ManagementGroupsValue Attribute Type",
				"While creating a ManagementGroupsValue value, an invalid attribute value was detected. "+
					"A ManagementGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ManagementGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ManagementGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ManagementGroupsValue Attribute Value",
				"While creating a ManagementGroupsValue value, an extra attribute value was detected. "+
					"A ManagementGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ManagementGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewManagementGroupsValueUnknown(), diags
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	existsAttribute, ok := attributes["exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exists is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	existsVal, ok := existsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exists expected to be basetypes.BoolValue, was: %T`, existsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	levelAttribute, ok := attributes["level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`level is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	levelVal, ok := levelAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`level expected to be basetypes.NumberValue, was: %T`, levelAttribute))
	}

	policyAssignmentsAttribute, ok := attributes["policy_assignments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignments is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	policyAssignmentsVal, ok := policyAssignmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignments expected to be basetypes.MapValue, was: %T`, policyAssignmentsAttribute))
	}

	policyDefinitionsAttribute, ok := attributes["policy_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_definitions is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	policyDefinitionsVal, ok := policyDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_definitions expected to be basetypes.MapValue, was: %T`, policyDefinitionsAttribute))
	}

	policySetDefinitionsAttribute, ok := attributes["policy_set_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_set_definitions is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	policySetDefinitionsVal, ok := policySetDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_set_definitions expected to be basetypes.MapValue, was: %T`, policySetDefinitionsAttribute))
	}

	roleDefinitionsAttribute, ok := attributes["role_definitions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_definitions is missing from object`)

		return NewManagementGroupsValueUnknown(), diags
	}

	roleDefinitionsVal, ok := roleDefinitionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_definitions expected to be basetypes.MapValue, was: %T`, roleDefinitionsAttribute))
	}

	if diags.HasError() {
		return NewManagementGroupsValueUnknown(), diags
	}

	return ManagementGroupsValue{
		DisplayName:          displayNameVal,
		Exists:               existsVal,
		Id:                   idVal,
		Level:                levelVal,
		PolicyAssignments:    policyAssignmentsVal,
		PolicyDefinitions:    policyDefinitionsVal,
		PolicySetDefinitions: policySetDefinitionsVal,
		RoleDefinitions:      roleDefinitionsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewManagementGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ManagementGroupsValue {
	object, diags := NewManagementGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewManagementGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ManagementGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewManagementGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewManagementGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewManagementGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewManagementGroupsValueMust(ManagementGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ManagementGroupsType) ValueType(ctx context.Context) attr.Value {
	return ManagementGroupsValue{}
}

var _ basetypes.ObjectValuable = ManagementGroupsValue{}

type ManagementGroupsValue struct {
	DisplayName          basetypes.StringValue `tfsdk:"display_name"`
	Exists               basetypes.BoolValue   `tfsdk:"exists"`
	Id                   basetypes.StringValue `tfsdk:"id"`
	Level                basetypes.NumberValue `tfsdk:"level"`
	PolicyAssignments    basetypes.MapValue    `tfsdk:"policy_assignments"`
	PolicyDefinitions    basetypes.MapValue    `tfsdk:"policy_definitions"`
	PolicySetDefinitions basetypes.MapValue    `tfsdk:"policy_set_definitions"`
	RoleDefinitions      basetypes.MapValue    `tfsdk:"role_definitions"`
	state                attr.ValueState
}

func (v ManagementGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exists"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["level"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["policy_assignments"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["policy_definitions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["policy_set_definitions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["role_definitions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Exists.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exists"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Level.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["level"] = val

		val, err = v.PolicyAssignments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_assignments"] = val

		val, err = v.PolicyDefinitions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_definitions"] = val

		val, err = v.PolicySetDefinitions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_set_definitions"] = val

		val, err = v.RoleDefinitions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_definitions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ManagementGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ManagementGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ManagementGroupsValue) String() string {
	return "ManagementGroupsValue"
}

func (v ManagementGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	policyAssignmentsVal, d := types.MapValue(types.StringType, v.PolicyAssignments.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"display_name": basetypes.StringType{},
			"exists":       basetypes.BoolType{},
			"id":           basetypes.StringType{},
			"level":        basetypes.NumberType{},
			"policy_assignments": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_set_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"role_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	policyDefinitionsVal, d := types.MapValue(types.StringType, v.PolicyDefinitions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"display_name": basetypes.StringType{},
			"exists":       basetypes.BoolType{},
			"id":           basetypes.StringType{},
			"level":        basetypes.NumberType{},
			"policy_assignments": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_set_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"role_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	policySetDefinitionsVal, d := types.MapValue(types.StringType, v.PolicySetDefinitions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"display_name": basetypes.StringType{},
			"exists":       basetypes.BoolType{},
			"id":           basetypes.StringType{},
			"level":        basetypes.NumberType{},
			"policy_assignments": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_set_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"role_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	roleDefinitionsVal, d := types.MapValue(types.StringType, v.RoleDefinitions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"display_name": basetypes.StringType{},
			"exists":       basetypes.BoolType{},
			"id":           basetypes.StringType{},
			"level":        basetypes.NumberType{},
			"policy_assignments": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"policy_set_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"role_definitions": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"display_name": basetypes.StringType{},
		"exists":       basetypes.BoolType{},
		"id":           basetypes.StringType{},
		"level":        basetypes.NumberType{},
		"policy_assignments": basetypes.MapType{
			ElemType: types.StringType,
		},
		"policy_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"policy_set_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"role_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"display_name":           v.DisplayName,
			"exists":                 v.Exists,
			"id":                     v.Id,
			"level":                  v.Level,
			"policy_assignments":     policyAssignmentsVal,
			"policy_definitions":     policyDefinitionsVal,
			"policy_set_definitions": policySetDefinitionsVal,
			"role_definitions":       roleDefinitionsVal,
		})

	return objVal, diags
}

func (v ManagementGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(ManagementGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Exists.Equal(other.Exists) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Level.Equal(other.Level) {
		return false
	}

	if !v.PolicyAssignments.Equal(other.PolicyAssignments) {
		return false
	}

	if !v.PolicyDefinitions.Equal(other.PolicyDefinitions) {
		return false
	}

	if !v.PolicySetDefinitions.Equal(other.PolicySetDefinitions) {
		return false
	}

	if !v.RoleDefinitions.Equal(other.RoleDefinitions) {
		return false
	}

	return true
}

func (v ManagementGroupsValue) Type(ctx context.Context) attr.Type {
	return ManagementGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ManagementGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"display_name": basetypes.StringType{},
		"exists":       basetypes.BoolType{},
		"id":           basetypes.StringType{},
		"level":        basetypes.NumberType{},
		"policy_assignments": basetypes.MapType{
			ElemType: types.StringType,
		},
		"policy_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"policy_set_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"role_definitions": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = PolicyAssignmentsToModifyType{}

type PolicyAssignmentsToModifyType struct {
	basetypes.ObjectType
}

func (t PolicyAssignmentsToModifyType) Equal(o attr.Type) bool {
	other, ok := o.(PolicyAssignmentsToModifyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PolicyAssignmentsToModifyType) String() string {
	return "PolicyAssignmentsToModifyType"
}

func (t PolicyAssignmentsToModifyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	policyAssignmentsAttribute, ok := attributes["policy_assignments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignments is missing from object`)

		return nil, diags
	}

	policyAssignmentsVal, ok := policyAssignmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignments expected to be basetypes.MapValue, was: %T`, policyAssignmentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PolicyAssignmentsToModifyValue{
		PolicyAssignments: policyAssignmentsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPolicyAssignmentsToModifyValueNull() PolicyAssignmentsToModifyValue {
	return PolicyAssignmentsToModifyValue{
		state: attr.ValueStateNull,
	}
}

func NewPolicyAssignmentsToModifyValueUnknown() PolicyAssignmentsToModifyValue {
	return PolicyAssignmentsToModifyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPolicyAssignmentsToModifyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PolicyAssignmentsToModifyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PolicyAssignmentsToModifyValue Attribute Value",
				"While creating a PolicyAssignmentsToModifyValue value, a missing attribute value was detected. "+
					"A PolicyAssignmentsToModifyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyAssignmentsToModifyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PolicyAssignmentsToModifyValue Attribute Type",
				"While creating a PolicyAssignmentsToModifyValue value, an invalid attribute value was detected. "+
					"A PolicyAssignmentsToModifyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyAssignmentsToModifyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PolicyAssignmentsToModifyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PolicyAssignmentsToModifyValue Attribute Value",
				"While creating a PolicyAssignmentsToModifyValue value, an extra attribute value was detected. "+
					"A PolicyAssignmentsToModifyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PolicyAssignmentsToModifyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPolicyAssignmentsToModifyValueUnknown(), diags
	}

	policyAssignmentsAttribute, ok := attributes["policy_assignments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_assignments is missing from object`)

		return NewPolicyAssignmentsToModifyValueUnknown(), diags
	}

	policyAssignmentsVal, ok := policyAssignmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_assignments expected to be basetypes.MapValue, was: %T`, policyAssignmentsAttribute))
	}

	if diags.HasError() {
		return NewPolicyAssignmentsToModifyValueUnknown(), diags
	}

	return PolicyAssignmentsToModifyValue{
		PolicyAssignments: policyAssignmentsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPolicyAssignmentsToModifyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PolicyAssignmentsToModifyValue {
	object, diags := NewPolicyAssignmentsToModifyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPolicyAssignmentsToModifyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PolicyAssignmentsToModifyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPolicyAssignmentsToModifyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPolicyAssignmentsToModifyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPolicyAssignmentsToModifyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPolicyAssignmentsToModifyValueMust(PolicyAssignmentsToModifyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PolicyAssignmentsToModifyType) ValueType(ctx context.Context) attr.Value {
	return PolicyAssignmentsToModifyValue{}
}

var _ basetypes.ObjectValuable = PolicyAssignmentsToModifyValue{}

type PolicyAssignmentsToModifyValue struct {
	PolicyAssignments basetypes.MapValue `tfsdk:"policy_assignments"`
	state             attr.ValueState
}

func (v PolicyAssignmentsToModifyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["policy_assignments"] = basetypes.MapType{
		ElemType: PolicyAssignmentsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.PolicyAssignments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_assignments"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PolicyAssignmentsToModifyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PolicyAssignmentsToModifyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PolicyAssignmentsToModifyValue) String() string {
	return "PolicyAssignmentsToModifyValue"
}

func (v PolicyAssignmentsToModifyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	policyAssignments := types.MapValueMust(
		PolicyAssignmentsType{
			basetypes.ObjectType{
				AttrTypes: PolicyAssignmentsValue{}.AttributeTypes(ctx),
			},
		},
		v.PolicyAssignments.Elements(),
	)

	if v.PolicyAssignments.IsNull() {
		policyAssignments = types.MapNull(
			PolicyAssignmentsType{
				basetypes.ObjectType{
					AttrTypes: PolicyAssignmentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PolicyAssignments.IsUnknown() {
		policyAssignments = types.MapUnknown(
			PolicyAssignmentsType{
				basetypes.ObjectType{
					AttrTypes: PolicyAssignmentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"policy_assignments": basetypes.MapType{
			ElemType: PolicyAssignmentsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"policy_assignments": policyAssignments,
		})

	return objVal, diags
}

func (v PolicyAssignmentsToModifyValue) Equal(o attr.Value) bool {
	other, ok := o.(PolicyAssignmentsToModifyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PolicyAssignments.Equal(other.PolicyAssignments) {
		return false
	}

	return true
}

func (v PolicyAssignmentsToModifyValue) Type(ctx context.Context) attr.Type {
	return PolicyAssignmentsToModifyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PolicyAssignmentsToModifyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"policy_assignments": basetypes.MapType{
			ElemType: PolicyAssignmentsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PolicyAssignmentsType{}

type PolicyAssignmentsType struct {
	basetypes.ObjectType
}

func (t PolicyAssignmentsType) Equal(o attr.Type) bool {
	other, ok := o.(PolicyAssignmentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PolicyAssignmentsType) String() string {
	return "PolicyAssignmentsType"
}

func (t PolicyAssignmentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enforcementModeAttribute, ok := attributes["enforcement_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enforcement_mode is missing from object`)

		return nil, diags
	}

	enforcementModeVal, ok := enforcementModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enforcement_mode expected to be basetypes.StringValue, was: %T`, enforcementModeAttribute))
	}

	identityAttribute, ok := attributes["identity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity is missing from object`)

		return nil, diags
	}

	identityVal, ok := identityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity expected to be basetypes.StringValue, was: %T`, identityAttribute))
	}

	identityIdsAttribute, ok := attributes["identity_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity_ids is missing from object`)

		return nil, diags
	}

	identityIdsVal, ok := identityIdsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity_ids expected to be basetypes.SetValue, was: %T`, identityIdsAttribute))
	}

	nonComplianceMessageAttribute, ok := attributes["non_compliance_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`non_compliance_message is missing from object`)

		return nil, diags
	}

	nonComplianceMessageVal, ok := nonComplianceMessageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`non_compliance_message expected to be basetypes.ObjectValue, was: %T`, nonComplianceMessageAttribute))
	}

	overridesAttribute, ok := attributes["overrides"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overrides is missing from object`)

		return nil, diags
	}

	overridesVal, ok := overridesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overrides expected to be basetypes.ListValue, was: %T`, overridesAttribute))
	}

	parametersAttribute, ok := attributes["parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parameters is missing from object`)

		return nil, diags
	}

	parametersVal, ok := parametersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parameters expected to be basetypes.StringValue, was: %T`, parametersAttribute))
	}

	resourceSelectorsAttribute, ok := attributes["resource_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_selectors is missing from object`)

		return nil, diags
	}

	resourceSelectorsVal, ok := resourceSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_selectors expected to be basetypes.ListValue, was: %T`, resourceSelectorsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PolicyAssignmentsValue{
		EnforcementMode:      enforcementModeVal,
		Identity:             identityVal,
		IdentityIds:          identityIdsVal,
		NonComplianceMessage: nonComplianceMessageVal,
		Overrides:            overridesVal,
		Parameters:           parametersVal,
		ResourceSelectors:    resourceSelectorsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPolicyAssignmentsValueNull() PolicyAssignmentsValue {
	return PolicyAssignmentsValue{
		state: attr.ValueStateNull,
	}
}

func NewPolicyAssignmentsValueUnknown() PolicyAssignmentsValue {
	return PolicyAssignmentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPolicyAssignmentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PolicyAssignmentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PolicyAssignmentsValue Attribute Value",
				"While creating a PolicyAssignmentsValue value, a missing attribute value was detected. "+
					"A PolicyAssignmentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyAssignmentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PolicyAssignmentsValue Attribute Type",
				"While creating a PolicyAssignmentsValue value, an invalid attribute value was detected. "+
					"A PolicyAssignmentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicyAssignmentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PolicyAssignmentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PolicyAssignmentsValue Attribute Value",
				"While creating a PolicyAssignmentsValue value, an extra attribute value was detected. "+
					"A PolicyAssignmentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PolicyAssignmentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPolicyAssignmentsValueUnknown(), diags
	}

	enforcementModeAttribute, ok := attributes["enforcement_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enforcement_mode is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	enforcementModeVal, ok := enforcementModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enforcement_mode expected to be basetypes.StringValue, was: %T`, enforcementModeAttribute))
	}

	identityAttribute, ok := attributes["identity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	identityVal, ok := identityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity expected to be basetypes.StringValue, was: %T`, identityAttribute))
	}

	identityIdsAttribute, ok := attributes["identity_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity_ids is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	identityIdsVal, ok := identityIdsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity_ids expected to be basetypes.SetValue, was: %T`, identityIdsAttribute))
	}

	nonComplianceMessageAttribute, ok := attributes["non_compliance_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`non_compliance_message is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	nonComplianceMessageVal, ok := nonComplianceMessageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`non_compliance_message expected to be basetypes.ObjectValue, was: %T`, nonComplianceMessageAttribute))
	}

	overridesAttribute, ok := attributes["overrides"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overrides is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	overridesVal, ok := overridesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overrides expected to be basetypes.ListValue, was: %T`, overridesAttribute))
	}

	parametersAttribute, ok := attributes["parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parameters is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	parametersVal, ok := parametersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parameters expected to be basetypes.StringValue, was: %T`, parametersAttribute))
	}

	resourceSelectorsAttribute, ok := attributes["resource_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_selectors is missing from object`)

		return NewPolicyAssignmentsValueUnknown(), diags
	}

	resourceSelectorsVal, ok := resourceSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_selectors expected to be basetypes.ListValue, was: %T`, resourceSelectorsAttribute))
	}

	if diags.HasError() {
		return NewPolicyAssignmentsValueUnknown(), diags
	}

	return PolicyAssignmentsValue{
		EnforcementMode:      enforcementModeVal,
		Identity:             identityVal,
		IdentityIds:          identityIdsVal,
		NonComplianceMessage: nonComplianceMessageVal,
		Overrides:            overridesVal,
		Parameters:           parametersVal,
		ResourceSelectors:    resourceSelectorsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPolicyAssignmentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PolicyAssignmentsValue {
	object, diags := NewPolicyAssignmentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPolicyAssignmentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PolicyAssignmentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPolicyAssignmentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPolicyAssignmentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPolicyAssignmentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPolicyAssignmentsValueMust(PolicyAssignmentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PolicyAssignmentsType) ValueType(ctx context.Context) attr.Value {
	return PolicyAssignmentsValue{}
}

var _ basetypes.ObjectValuable = PolicyAssignmentsValue{}

type PolicyAssignmentsValue struct {
	EnforcementMode      basetypes.StringValue `tfsdk:"enforcement_mode"`
	Identity             basetypes.StringValue `tfsdk:"identity"`
	IdentityIds          basetypes.SetValue    `tfsdk:"identity_ids"`
	NonComplianceMessage basetypes.ObjectValue `tfsdk:"non_compliance_message"`
	Overrides            basetypes.ListValue   `tfsdk:"overrides"`
	Parameters           basetypes.StringValue `tfsdk:"parameters"`
	ResourceSelectors    basetypes.ListValue   `tfsdk:"resource_selectors"`
	state                attr.ValueState
}

func (v PolicyAssignmentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["enforcement_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["identity"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["identity_ids"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["non_compliance_message"] = basetypes.ObjectType{
		AttrTypes: NonComplianceMessageValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["overrides"] = basetypes.ListType{
		ElemType: OverridesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["parameters"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_selectors"] = basetypes.ListType{
		ElemType: ResourceSelectorsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.EnforcementMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enforcement_mode"] = val

		val, err = v.Identity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identity"] = val

		val, err = v.IdentityIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identity_ids"] = val

		val, err = v.NonComplianceMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["non_compliance_message"] = val

		val, err = v.Overrides.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overrides"] = val

		val, err = v.Parameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parameters"] = val

		val, err = v.ResourceSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_selectors"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PolicyAssignmentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PolicyAssignmentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PolicyAssignmentsValue) String() string {
	return "PolicyAssignmentsValue"
}

func (v PolicyAssignmentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nonComplianceMessage basetypes.ObjectValue

	if v.NonComplianceMessage.IsNull() {
		nonComplianceMessage = types.ObjectNull(
			NonComplianceMessageValue{}.AttributeTypes(ctx),
		)
	}

	if v.NonComplianceMessage.IsUnknown() {
		nonComplianceMessage = types.ObjectUnknown(
			NonComplianceMessageValue{}.AttributeTypes(ctx),
		)
	}

	if !v.NonComplianceMessage.IsNull() && !v.NonComplianceMessage.IsUnknown() {
		nonComplianceMessage = types.ObjectValueMust(
			NonComplianceMessageValue{}.AttributeTypes(ctx),
			v.NonComplianceMessage.Attributes(),
		)
	}

	overrides := types.ListValueMust(
		OverridesType{
			basetypes.ObjectType{
				AttrTypes: OverridesValue{}.AttributeTypes(ctx),
			},
		},
		v.Overrides.Elements(),
	)

	if v.Overrides.IsNull() {
		overrides = types.ListNull(
			OverridesType{
				basetypes.ObjectType{
					AttrTypes: OverridesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Overrides.IsUnknown() {
		overrides = types.ListUnknown(
			OverridesType{
				basetypes.ObjectType{
					AttrTypes: OverridesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	resourceSelectors := types.ListValueMust(
		ResourceSelectorsType{
			basetypes.ObjectType{
				AttrTypes: ResourceSelectorsValue{}.AttributeTypes(ctx),
			},
		},
		v.ResourceSelectors.Elements(),
	)

	if v.ResourceSelectors.IsNull() {
		resourceSelectors = types.ListNull(
			ResourceSelectorsType{
				basetypes.ObjectType{
					AttrTypes: ResourceSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ResourceSelectors.IsUnknown() {
		resourceSelectors = types.ListUnknown(
			ResourceSelectorsType{
				basetypes.ObjectType{
					AttrTypes: ResourceSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	identityIdsVal, d := types.SetValue(types.StringType, v.IdentityIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enforcement_mode": basetypes.StringType{},
			"identity":         basetypes.StringType{},
			"identity_ids": basetypes.SetType{
				ElemType: types.StringType,
			},
			"non_compliance_message": basetypes.ObjectType{
				AttrTypes: NonComplianceMessageValue{}.AttributeTypes(ctx),
			},
			"overrides": basetypes.ListType{
				ElemType: OverridesValue{}.Type(ctx),
			},
			"parameters": basetypes.StringType{},
			"resource_selectors": basetypes.ListType{
				ElemType: ResourceSelectorsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enforcement_mode": basetypes.StringType{},
		"identity":         basetypes.StringType{},
		"identity_ids": basetypes.SetType{
			ElemType: types.StringType,
		},
		"non_compliance_message": basetypes.ObjectType{
			AttrTypes: NonComplianceMessageValue{}.AttributeTypes(ctx),
		},
		"overrides": basetypes.ListType{
			ElemType: OverridesValue{}.Type(ctx),
		},
		"parameters": basetypes.StringType{},
		"resource_selectors": basetypes.ListType{
			ElemType: ResourceSelectorsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enforcement_mode":       v.EnforcementMode,
			"identity":               v.Identity,
			"identity_ids":           identityIdsVal,
			"non_compliance_message": nonComplianceMessage,
			"overrides":              overrides,
			"parameters":             v.Parameters,
			"resource_selectors":     resourceSelectors,
		})

	return objVal, diags
}

func (v PolicyAssignmentsValue) Equal(o attr.Value) bool {
	other, ok := o.(PolicyAssignmentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnforcementMode.Equal(other.EnforcementMode) {
		return false
	}

	if !v.Identity.Equal(other.Identity) {
		return false
	}

	if !v.IdentityIds.Equal(other.IdentityIds) {
		return false
	}

	if !v.NonComplianceMessage.Equal(other.NonComplianceMessage) {
		return false
	}

	if !v.Overrides.Equal(other.Overrides) {
		return false
	}

	if !v.Parameters.Equal(other.Parameters) {
		return false
	}

	if !v.ResourceSelectors.Equal(other.ResourceSelectors) {
		return false
	}

	return true
}

func (v PolicyAssignmentsValue) Type(ctx context.Context) attr.Type {
	return PolicyAssignmentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PolicyAssignmentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enforcement_mode": basetypes.StringType{},
		"identity":         basetypes.StringType{},
		"identity_ids": basetypes.SetType{
			ElemType: types.StringType,
		},
		"non_compliance_message": basetypes.ObjectType{
			AttrTypes: NonComplianceMessageValue{}.AttributeTypes(ctx),
		},
		"overrides": basetypes.ListType{
			ElemType: OverridesValue{}.Type(ctx),
		},
		"parameters": basetypes.StringType{},
		"resource_selectors": basetypes.ListType{
			ElemType: ResourceSelectorsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = NonComplianceMessageType{}

type NonComplianceMessageType struct {
	basetypes.ObjectType
}

func (t NonComplianceMessageType) Equal(o attr.Type) bool {
	other, ok := o.(NonComplianceMessageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NonComplianceMessageType) String() string {
	return "NonComplianceMessageType"
}

func (t NonComplianceMessageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return nil, diags
	}

	messageVal, ok := messageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be basetypes.StringValue, was: %T`, messageAttribute))
	}

	policyDefinitionReferenceIdAttribute, ok := attributes["policy_definition_reference_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_definition_reference_id is missing from object`)

		return nil, diags
	}

	policyDefinitionReferenceIdVal, ok := policyDefinitionReferenceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_definition_reference_id expected to be basetypes.StringValue, was: %T`, policyDefinitionReferenceIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NonComplianceMessageValue{
		Message:                     messageVal,
		PolicyDefinitionReferenceId: policyDefinitionReferenceIdVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewNonComplianceMessageValueNull() NonComplianceMessageValue {
	return NonComplianceMessageValue{
		state: attr.ValueStateNull,
	}
}

func NewNonComplianceMessageValueUnknown() NonComplianceMessageValue {
	return NonComplianceMessageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNonComplianceMessageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NonComplianceMessageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NonComplianceMessageValue Attribute Value",
				"While creating a NonComplianceMessageValue value, a missing attribute value was detected. "+
					"A NonComplianceMessageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NonComplianceMessageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NonComplianceMessageValue Attribute Type",
				"While creating a NonComplianceMessageValue value, an invalid attribute value was detected. "+
					"A NonComplianceMessageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NonComplianceMessageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NonComplianceMessageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NonComplianceMessageValue Attribute Value",
				"While creating a NonComplianceMessageValue value, an extra attribute value was detected. "+
					"A NonComplianceMessageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NonComplianceMessageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNonComplianceMessageValueUnknown(), diags
	}

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return NewNonComplianceMessageValueUnknown(), diags
	}

	messageVal, ok := messageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be basetypes.StringValue, was: %T`, messageAttribute))
	}

	policyDefinitionReferenceIdAttribute, ok := attributes["policy_definition_reference_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_definition_reference_id is missing from object`)

		return NewNonComplianceMessageValueUnknown(), diags
	}

	policyDefinitionReferenceIdVal, ok := policyDefinitionReferenceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_definition_reference_id expected to be basetypes.StringValue, was: %T`, policyDefinitionReferenceIdAttribute))
	}

	if diags.HasError() {
		return NewNonComplianceMessageValueUnknown(), diags
	}

	return NonComplianceMessageValue{
		Message:                     messageVal,
		PolicyDefinitionReferenceId: policyDefinitionReferenceIdVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewNonComplianceMessageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NonComplianceMessageValue {
	object, diags := NewNonComplianceMessageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNonComplianceMessageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NonComplianceMessageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNonComplianceMessageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNonComplianceMessageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNonComplianceMessageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNonComplianceMessageValueMust(NonComplianceMessageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NonComplianceMessageType) ValueType(ctx context.Context) attr.Value {
	return NonComplianceMessageValue{}
}

var _ basetypes.ObjectValuable = NonComplianceMessageValue{}

type NonComplianceMessageValue struct {
	Message                     basetypes.StringValue `tfsdk:"message"`
	PolicyDefinitionReferenceId basetypes.StringValue `tfsdk:"policy_definition_reference_id"`
	state                       attr.ValueState
}

func (v NonComplianceMessageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["policy_definition_reference_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Message.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message"] = val

		val, err = v.PolicyDefinitionReferenceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_definition_reference_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NonComplianceMessageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NonComplianceMessageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NonComplianceMessageValue) String() string {
	return "NonComplianceMessageValue"
}

func (v NonComplianceMessageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"message":                        basetypes.StringType{},
		"policy_definition_reference_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"message":                        v.Message,
			"policy_definition_reference_id": v.PolicyDefinitionReferenceId,
		})

	return objVal, diags
}

func (v NonComplianceMessageValue) Equal(o attr.Value) bool {
	other, ok := o.(NonComplianceMessageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Message.Equal(other.Message) {
		return false
	}

	if !v.PolicyDefinitionReferenceId.Equal(other.PolicyDefinitionReferenceId) {
		return false
	}

	return true
}

func (v NonComplianceMessageValue) Type(ctx context.Context) attr.Type {
	return NonComplianceMessageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NonComplianceMessageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"message":                        basetypes.StringType{},
		"policy_definition_reference_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OverridesType{}

type OverridesType struct {
	basetypes.ObjectType
}

func (t OverridesType) Equal(o attr.Type) bool {
	other, ok := o.(OverridesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverridesType) String() string {
	return "OverridesType"
}

func (t OverridesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	overrideSelectorsAttribute, ok := attributes["override_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_selectors is missing from object`)

		return nil, diags
	}

	overrideSelectorsVal, ok := overrideSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_selectors expected to be basetypes.ListValue, was: %T`, overrideSelectorsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverridesValue{
		Kind:              kindVal,
		OverrideSelectors: overrideSelectorsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewOverridesValueNull() OverridesValue {
	return OverridesValue{
		state: attr.ValueStateNull,
	}
}

func NewOverridesValueUnknown() OverridesValue {
	return OverridesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverridesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverridesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverridesValue Attribute Value",
				"While creating a OverridesValue value, a missing attribute value was detected. "+
					"A OverridesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverridesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverridesValue Attribute Type",
				"While creating a OverridesValue value, an invalid attribute value was detected. "+
					"A OverridesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverridesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverridesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverridesValue Attribute Value",
				"While creating a OverridesValue value, an extra attribute value was detected. "+
					"A OverridesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverridesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverridesValueUnknown(), diags
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewOverridesValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	overrideSelectorsAttribute, ok := attributes["override_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_selectors is missing from object`)

		return NewOverridesValueUnknown(), diags
	}

	overrideSelectorsVal, ok := overrideSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_selectors expected to be basetypes.ListValue, was: %T`, overrideSelectorsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewOverridesValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewOverridesValueUnknown(), diags
	}

	return OverridesValue{
		Kind:              kindVal,
		OverrideSelectors: overrideSelectorsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewOverridesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverridesValue {
	object, diags := NewOverridesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverridesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverridesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverridesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverridesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverridesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverridesValueMust(OverridesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverridesType) ValueType(ctx context.Context) attr.Value {
	return OverridesValue{}
}

var _ basetypes.ObjectValuable = OverridesValue{}

type OverridesValue struct {
	Kind              basetypes.StringValue `tfsdk:"kind"`
	OverrideSelectors basetypes.ListValue   `tfsdk:"override_selectors"`
	Value             basetypes.StringValue `tfsdk:"value"`
	state             attr.ValueState
}

func (v OverridesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["override_selectors"] = basetypes.ListType{
		ElemType: OverrideSelectorsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.OverrideSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["override_selectors"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverridesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverridesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverridesValue) String() string {
	return "OverridesValue"
}

func (v OverridesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	overrideSelectors := types.ListValueMust(
		OverrideSelectorsType{
			basetypes.ObjectType{
				AttrTypes: OverrideSelectorsValue{}.AttributeTypes(ctx),
			},
		},
		v.OverrideSelectors.Elements(),
	)

	if v.OverrideSelectors.IsNull() {
		overrideSelectors = types.ListNull(
			OverrideSelectorsType{
				basetypes.ObjectType{
					AttrTypes: OverrideSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OverrideSelectors.IsUnknown() {
		overrideSelectors = types.ListUnknown(
			OverrideSelectorsType{
				basetypes.ObjectType{
					AttrTypes: OverrideSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"kind": basetypes.StringType{},
		"override_selectors": basetypes.ListType{
			ElemType: OverrideSelectorsValue{}.Type(ctx),
		},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"kind":               v.Kind,
			"override_selectors": overrideSelectors,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v OverridesValue) Equal(o attr.Value) bool {
	other, ok := o.(OverridesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.OverrideSelectors.Equal(other.OverrideSelectors) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v OverridesValue) Type(ctx context.Context) attr.Type {
	return OverridesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverridesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"kind": basetypes.StringType{},
		"override_selectors": basetypes.ListType{
			ElemType: OverrideSelectorsValue{}.Type(ctx),
		},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OverrideSelectorsType{}

type OverrideSelectorsType struct {
	basetypes.ObjectType
}

func (t OverrideSelectorsType) Equal(o attr.Type) bool {
	other, ok := o.(OverrideSelectorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverrideSelectorsType) String() string {
	return "OverrideSelectorsType"
}

func (t OverrideSelectorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inAttribute, ok := attributes["in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in is missing from object`)

		return nil, diags
	}

	inVal, ok := inAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in expected to be basetypes.SetValue, was: %T`, inAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	notInAttribute, ok := attributes["not_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_in is missing from object`)

		return nil, diags
	}

	notInVal, ok := notInAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_in expected to be basetypes.SetValue, was: %T`, notInAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverrideSelectorsValue{
		In:    inVal,
		Kind:  kindVal,
		NotIn: notInVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOverrideSelectorsValueNull() OverrideSelectorsValue {
	return OverrideSelectorsValue{
		state: attr.ValueStateNull,
	}
}

func NewOverrideSelectorsValueUnknown() OverrideSelectorsValue {
	return OverrideSelectorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverrideSelectorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverrideSelectorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverrideSelectorsValue Attribute Value",
				"While creating a OverrideSelectorsValue value, a missing attribute value was detected. "+
					"A OverrideSelectorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverrideSelectorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverrideSelectorsValue Attribute Type",
				"While creating a OverrideSelectorsValue value, an invalid attribute value was detected. "+
					"A OverrideSelectorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverrideSelectorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverrideSelectorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverrideSelectorsValue Attribute Value",
				"While creating a OverrideSelectorsValue value, an extra attribute value was detected. "+
					"A OverrideSelectorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverrideSelectorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverrideSelectorsValueUnknown(), diags
	}

	inAttribute, ok := attributes["in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in is missing from object`)

		return NewOverrideSelectorsValueUnknown(), diags
	}

	inVal, ok := inAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in expected to be basetypes.SetValue, was: %T`, inAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewOverrideSelectorsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	notInAttribute, ok := attributes["not_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_in is missing from object`)

		return NewOverrideSelectorsValueUnknown(), diags
	}

	notInVal, ok := notInAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_in expected to be basetypes.SetValue, was: %T`, notInAttribute))
	}

	if diags.HasError() {
		return NewOverrideSelectorsValueUnknown(), diags
	}

	return OverrideSelectorsValue{
		In:    inVal,
		Kind:  kindVal,
		NotIn: notInVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOverrideSelectorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverrideSelectorsValue {
	object, diags := NewOverrideSelectorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverrideSelectorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverrideSelectorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverrideSelectorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverrideSelectorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverrideSelectorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverrideSelectorsValueMust(OverrideSelectorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverrideSelectorsType) ValueType(ctx context.Context) attr.Value {
	return OverrideSelectorsValue{}
}

var _ basetypes.ObjectValuable = OverrideSelectorsValue{}

type OverrideSelectorsValue struct {
	In    basetypes.SetValue    `tfsdk:"in"`
	Kind  basetypes.StringValue `tfsdk:"kind"`
	NotIn basetypes.SetValue    `tfsdk:"not_in"`
	state attr.ValueState
}

func (v OverrideSelectorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["in"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_in"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.In.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["in"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.NotIn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_in"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverrideSelectorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverrideSelectorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverrideSelectorsValue) String() string {
	return "OverrideSelectorsValue"
}

func (v OverrideSelectorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	inVal, d := types.SetValue(types.StringType, v.In.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"in": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kind": basetypes.StringType{},
			"not_in": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	notInVal, d := types.SetValue(types.StringType, v.NotIn.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"in": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kind": basetypes.StringType{},
			"not_in": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"in": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kind": basetypes.StringType{},
		"not_in": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"in":     inVal,
			"kind":   v.Kind,
			"not_in": notInVal,
		})

	return objVal, diags
}

func (v OverrideSelectorsValue) Equal(o attr.Value) bool {
	other, ok := o.(OverrideSelectorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.In.Equal(other.In) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.NotIn.Equal(other.NotIn) {
		return false
	}

	return true
}

func (v OverrideSelectorsValue) Type(ctx context.Context) attr.Type {
	return OverrideSelectorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverrideSelectorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"in": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kind": basetypes.StringType{},
		"not_in": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ResourceSelectorsType{}

type ResourceSelectorsType struct {
	basetypes.ObjectType
}

func (t ResourceSelectorsType) Equal(o attr.Type) bool {
	other, ok := o.(ResourceSelectorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourceSelectorsType) String() string {
	return "ResourceSelectorsType"
}

func (t ResourceSelectorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceSelectorSelectorsAttribute, ok := attributes["resource_selector_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_selector_selectors is missing from object`)

		return nil, diags
	}

	resourceSelectorSelectorsVal, ok := resourceSelectorSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_selector_selectors expected to be basetypes.ListValue, was: %T`, resourceSelectorSelectorsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourceSelectorsValue{
		Name:                      nameVal,
		ResourceSelectorSelectors: resourceSelectorSelectorsVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewResourceSelectorsValueNull() ResourceSelectorsValue {
	return ResourceSelectorsValue{
		state: attr.ValueStateNull,
	}
}

func NewResourceSelectorsValueUnknown() ResourceSelectorsValue {
	return ResourceSelectorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourceSelectorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourceSelectorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourceSelectorsValue Attribute Value",
				"While creating a ResourceSelectorsValue value, a missing attribute value was detected. "+
					"A ResourceSelectorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceSelectorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourceSelectorsValue Attribute Type",
				"While creating a ResourceSelectorsValue value, an invalid attribute value was detected. "+
					"A ResourceSelectorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceSelectorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourceSelectorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourceSelectorsValue Attribute Value",
				"While creating a ResourceSelectorsValue value, an extra attribute value was detected. "+
					"A ResourceSelectorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourceSelectorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourceSelectorsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewResourceSelectorsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceSelectorSelectorsAttribute, ok := attributes["resource_selector_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_selector_selectors is missing from object`)

		return NewResourceSelectorsValueUnknown(), diags
	}

	resourceSelectorSelectorsVal, ok := resourceSelectorSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_selector_selectors expected to be basetypes.ListValue, was: %T`, resourceSelectorSelectorsAttribute))
	}

	if diags.HasError() {
		return NewResourceSelectorsValueUnknown(), diags
	}

	return ResourceSelectorsValue{
		Name:                      nameVal,
		ResourceSelectorSelectors: resourceSelectorSelectorsVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewResourceSelectorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourceSelectorsValue {
	object, diags := NewResourceSelectorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourceSelectorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourceSelectorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourceSelectorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourceSelectorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourceSelectorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourceSelectorsValueMust(ResourceSelectorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourceSelectorsType) ValueType(ctx context.Context) attr.Value {
	return ResourceSelectorsValue{}
}

var _ basetypes.ObjectValuable = ResourceSelectorsValue{}

type ResourceSelectorsValue struct {
	Name                      basetypes.StringValue `tfsdk:"name"`
	ResourceSelectorSelectors basetypes.ListValue   `tfsdk:"resource_selector_selectors"`
	state                     attr.ValueState
}

func (v ResourceSelectorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_selector_selectors"] = basetypes.ListType{
		ElemType: ResourceSelectorSelectorsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ResourceSelectorSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_selector_selectors"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourceSelectorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourceSelectorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourceSelectorsValue) String() string {
	return "ResourceSelectorsValue"
}

func (v ResourceSelectorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	resourceSelectorSelectors := types.ListValueMust(
		ResourceSelectorSelectorsType{
			basetypes.ObjectType{
				AttrTypes: ResourceSelectorSelectorsValue{}.AttributeTypes(ctx),
			},
		},
		v.ResourceSelectorSelectors.Elements(),
	)

	if v.ResourceSelectorSelectors.IsNull() {
		resourceSelectorSelectors = types.ListNull(
			ResourceSelectorSelectorsType{
				basetypes.ObjectType{
					AttrTypes: ResourceSelectorSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ResourceSelectorSelectors.IsUnknown() {
		resourceSelectorSelectors = types.ListUnknown(
			ResourceSelectorSelectorsType{
				basetypes.ObjectType{
					AttrTypes: ResourceSelectorSelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"resource_selector_selectors": basetypes.ListType{
			ElemType: ResourceSelectorSelectorsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":                        v.Name,
			"resource_selector_selectors": resourceSelectorSelectors,
		})

	return objVal, diags
}

func (v ResourceSelectorsValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourceSelectorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ResourceSelectorSelectors.Equal(other.ResourceSelectorSelectors) {
		return false
	}

	return true
}

func (v ResourceSelectorsValue) Type(ctx context.Context) attr.Type {
	return ResourceSelectorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourceSelectorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"resource_selector_selectors": basetypes.ListType{
			ElemType: ResourceSelectorSelectorsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ResourceSelectorSelectorsType{}

type ResourceSelectorSelectorsType struct {
	basetypes.ObjectType
}

func (t ResourceSelectorSelectorsType) Equal(o attr.Type) bool {
	other, ok := o.(ResourceSelectorSelectorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourceSelectorSelectorsType) String() string {
	return "ResourceSelectorSelectorsType"
}

func (t ResourceSelectorSelectorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inAttribute, ok := attributes["in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in is missing from object`)

		return nil, diags
	}

	inVal, ok := inAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in expected to be basetypes.SetValue, was: %T`, inAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	notInAttribute, ok := attributes["not_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_in is missing from object`)

		return nil, diags
	}

	notInVal, ok := notInAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_in expected to be basetypes.SetValue, was: %T`, notInAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourceSelectorSelectorsValue{
		In:    inVal,
		Kind:  kindVal,
		NotIn: notInVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewResourceSelectorSelectorsValueNull() ResourceSelectorSelectorsValue {
	return ResourceSelectorSelectorsValue{
		state: attr.ValueStateNull,
	}
}

func NewResourceSelectorSelectorsValueUnknown() ResourceSelectorSelectorsValue {
	return ResourceSelectorSelectorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourceSelectorSelectorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourceSelectorSelectorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourceSelectorSelectorsValue Attribute Value",
				"While creating a ResourceSelectorSelectorsValue value, a missing attribute value was detected. "+
					"A ResourceSelectorSelectorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceSelectorSelectorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourceSelectorSelectorsValue Attribute Type",
				"While creating a ResourceSelectorSelectorsValue value, an invalid attribute value was detected. "+
					"A ResourceSelectorSelectorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceSelectorSelectorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourceSelectorSelectorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourceSelectorSelectorsValue Attribute Value",
				"While creating a ResourceSelectorSelectorsValue value, an extra attribute value was detected. "+
					"A ResourceSelectorSelectorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourceSelectorSelectorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	inAttribute, ok := attributes["in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`in is missing from object`)

		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	inVal, ok := inAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`in expected to be basetypes.SetValue, was: %T`, inAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	notInAttribute, ok := attributes["not_in"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_in is missing from object`)

		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	notInVal, ok := notInAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_in expected to be basetypes.SetValue, was: %T`, notInAttribute))
	}

	if diags.HasError() {
		return NewResourceSelectorSelectorsValueUnknown(), diags
	}

	return ResourceSelectorSelectorsValue{
		In:    inVal,
		Kind:  kindVal,
		NotIn: notInVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewResourceSelectorSelectorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourceSelectorSelectorsValue {
	object, diags := NewResourceSelectorSelectorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourceSelectorSelectorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourceSelectorSelectorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourceSelectorSelectorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourceSelectorSelectorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourceSelectorSelectorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourceSelectorSelectorsValueMust(ResourceSelectorSelectorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourceSelectorSelectorsType) ValueType(ctx context.Context) attr.Value {
	return ResourceSelectorSelectorsValue{}
}

var _ basetypes.ObjectValuable = ResourceSelectorSelectorsValue{}

type ResourceSelectorSelectorsValue struct {
	In    basetypes.SetValue    `tfsdk:"in"`
	Kind  basetypes.StringValue `tfsdk:"kind"`
	NotIn basetypes.SetValue    `tfsdk:"not_in"`
	state attr.ValueState
}

func (v ResourceSelectorSelectorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["in"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_in"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.In.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["in"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.NotIn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_in"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourceSelectorSelectorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourceSelectorSelectorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourceSelectorSelectorsValue) String() string {
	return "ResourceSelectorSelectorsValue"
}

func (v ResourceSelectorSelectorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	inVal, d := types.SetValue(types.StringType, v.In.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"in": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kind": basetypes.StringType{},
			"not_in": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	notInVal, d := types.SetValue(types.StringType, v.NotIn.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"in": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kind": basetypes.StringType{},
			"not_in": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"in": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kind": basetypes.StringType{},
		"not_in": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"in":     inVal,
			"kind":   v.Kind,
			"not_in": notInVal,
		})

	return objVal, diags
}

func (v ResourceSelectorSelectorsValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourceSelectorSelectorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.In.Equal(other.In) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.NotIn.Equal(other.NotIn) {
		return false
	}

	return true
}

func (v ResourceSelectorSelectorsValue) Type(ctx context.Context) attr.Type {
	return ResourceSelectorSelectorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourceSelectorSelectorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"in": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kind": basetypes.StringType{},
		"not_in": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}
